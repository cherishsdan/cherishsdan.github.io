<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[js实现的数据结构、排序算法~~]]></title>
      <url>http://yoursite.com/2016/09/17/js-algorithms/</url>
      <content type="html"><![CDATA[<p>用JavaScript实现了经典的十大排序算法，以及一些简单的数据结构,持续更新~<br>相信随着ES6的普及，js会越来越完善  (≧▽≦)~</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>  分别使用 基本写法、IIFE、ES6 3中形式实现</p>
<ul>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/tree/master/data-structure/set" target="_blank" rel="external">Set</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/tree/master/data-structure/Queue" target="_blank" rel="external">Queue</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/tree/master/data-structure/stack" target="_blank" rel="external">stack</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/tree/master/data-structure/Tree" target="_blank" rel="external">Tree</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/tree/master/data-structure/List" target="_blank" rel="external">List</a><a id="more"></a>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2>实现了经典的十大排序算法，分析了各个算法的时间、空间复杂度~~</li>
</ul>
<ul>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/sort/Bubble.js" target="_blank" rel="external">冒泡排序</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/sort/insertion.js" target="_blank" rel="external">插入排序</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/sort/selectionSort.js" target="_blank" rel="external">选择排序</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/sort/merge.js" target="_blank" rel="external">归并排序</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/sort/shell.js" target="_blank" rel="external">希尔排序</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/sort/heapSort.js" target="_blank" rel="external">堆排序</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/sort/quickSort.js" target="_blank" rel="external">快速排序</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/sort/countSort.js" target="_blank" rel="external">计数排序</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/sort/bucketSort.js" target="_blank" rel="external">桶排序</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/sort/radixSort.js" target="_blank" rel="external">基数排序</a></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>数组、字符串常用操作的一些总结</p>
<ul>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/simpleMethods/array/unique.js" target="_blank" rel="external">数组去重</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/simpleMethods/array/disorderArr.js" target="_blank" rel="external">数组乱序</a></li>
<li><a href="https://github.com/cherishsdan/js-data-structures-algorithms/blob/master/simpleMethods/array/flattening.js" target="_blank" rel="external">数组扁平化</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP HTTPs HTTP2]]></title>
      <url>http://yoursite.com/2016/09/16/httpAbout/</url>
      <content type="html"><![CDATA[<p>HTTP协议缺省工作在TCP协议80端口，所有传输的内容都是明文。<br>HTTPS简单来说，是HTTP的安全版本，运行在SSL/TLS之上，SSL/TLS运行在TCP的443端口之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。<br>HTTP2 在HTTP协议的语义、方法、状态码等核心概念不变的情况下，实现了性能优化<br><a id="more"></a></p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。<br>使用非对称加密算法保证对称加密密钥的安全传递，然后使用对称加密来保证数据传输过程中的安全性<br>它的传输过程：</p>
<pre><code>* TCP 三次握手
* client将自己支持的一套加密规则发送给server
* server从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给client。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息（采用HTTPS服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己制作的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面）
* 传送证书（其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等）
* 客户端验证及解析服务器数字证书（验证公钥是否有效，比如颁发机构，过期时间等等），产生一个用于后面通讯的“对称密码”，并用证书中提供的公钥加密
* 发送加密后的对称秘钥
* server用私钥解密后，得到了客户端传过来的随机值，使用随机值对消息进行对称加密，发送给client
* client解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。
</code></pre><h2 id="HTTP现状"><a href="#HTTP现状" class="headerlink" title="HTTP现状"></a>HTTP现状</h2><pre><code>* HTTP1.1过于庞大，包含了太多细节和可选的部分
* 未能充分利用TCP
* 线头阻塞（Head of line blocking），导致带宽无法被充分利用，以及后续健康请求被阻塞
* 延迟
</code></pre><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><h4 id="HTTP2的新特性"><a href="#HTTP2的新特性" class="headerlink" title="HTTP2的新特性"></a>HTTP2的新特性</h4><ul>
<li>新的二进制格式<br>  http1.x诞生的时候是明文协议，解析是基于文本，基于文本协议的格式解析存在天然缺陷，因为文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑http2.0的协议解析决定采用二进制格式，实现方便且健壮。<br>  HTTP/2将所有传输的信息分割为更小的消息和帧<ul>
<li>帧（frame）：HTTP/2通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流。</li>
<li>消息（message）：由一个或多个帧组合而成，例如请求和响应。</li>
<li>连接（connection）：与 HTTP/1 相同，都是指对应的 TCP 连接；</li>
<li>流（stream）：已建立的连接上的双向字节流。<br><img src="https://github.com/music4kid/music4kid.github.io/blob/master/images/http1xvs2.png?raw=true" alt="http2"><br>http2.0的格式定义更接近tcp层的方式。length定义了整个frame的开始到结束，type定义frame的类型（一共10种），flags用bit位定义一些重要的参数，stream id用作流控制，剩下的payload就是request的正文了。http2.0并没有改变http1.x的语义，只是把原来http1.x的header和body部分用frame重新封装了一层而已.<br>在HTTP/2中，数据流以消息的形式发送，而消息由一个或多个帧组成，帧可以在数据流上乱序发送，然后再根据每个帧首部的流标识符重新组装</li>
</ul>
</li>
<li>多路复用<br>  HTTP1.x中，如果想并发多个请求，必须使用多个TCP链接，且浏览器为了控制资源，还会对单个域名有6-8的个数限制<br>  HTTP2中，同域名下所有通信都在单个连接上完成。单个连接可以承载任意数量的双向数据流。<br>  一个request对应一个stream并分配一个id，这样一个连接上可以有多个stream，每个stream的frame可以随机的混杂在一起，接收方可以根据stream id将frame再归属到各自不同的request里面。<br>  即单个连接上可以并行交错的请求和响应，之间互不干扰。</li>
<li>流优先级<br>  在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</li>
<li>服务器推送<br>  服务器推送的资源有自己独立的URL，可以被浏览器缓存，可以达到多页面共享。<br>  资源推送遵守同源策略，服务器不可随便推送第三方资源给客户端。<br>  客户端可以拒绝推送过来的资源。</li>
<li>头部压缩<br>  http1.x的header由于cookie和user agent很容易膨胀，而且每次都要重复发送。http2.0使用encoder来减少需要传输的header大小，通讯双方各自渐进地更新一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。</li>
<li>APLN<br>  HTTP2.0使用了tls的拓展ALPN来做协议升级，除此之外加密这块还有一个改动，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法</li>
</ul>
<h4 id="HTTP2-与-web性能优化"><a href="#HTTP2-与-web性能优化" class="headerlink" title="HTTP2 与 web性能优化"></a>HTTP2 与 web性能优化</h4><ul>
<li>资源加载<ul>
<li>现有解决方案：资源内联、强缓存、localstorage、将重要资源内联在页面头部</li>
<li>HTTP2中的Server Push，</li>
</ul>
</li>
<li>TCP 连接<ul>
<li>连接数优化（并发连接 + Keep-Alive、静态资源做域名散列、异步接口合并、图片合并，雪碧图、CSS、JS 合并/内联、图片内联…）</li>
<li>HTTP/2 的多路复用和头部压缩</li>
</ul>
</li>
</ul>
<p>参考：<br><a href="https://www.gitbook.com/book/ye11ow/http2-explained" target="_blank" rel="external">https://www.gitbook.com/book/ye11ow/http2-explained</a><br><a href="https://imququ.com/post/http2-resource.html" target="_blank" rel="external">https://imququ.com/post/http2-resource.html</a><br><a href="http://mrpeak.cn/blog/http2/" target="_blank" rel="external">http://mrpeak.cn/blog/http2/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[react相关]]></title>
      <url>http://yoursite.com/2016/08/31/react-1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>记录一些react的知识点及资料</p>
</blockquote>
<p>虚拟DOM是React核心，通过diff比较算法，实现了对界面上真正变化的部分进行实际的DOM操作</p>
<h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><pre><code>传统的diff算法的时间复杂度是 O(n^3)，它会以根据before和after的最长子节点长度，循环遍历所有子节点，然后判断子节点的更新状态
react中的diff算法将时间复杂度降为 O(n), 分别对 tree diff、component diff 以及 element diff 进行算法优化
[more](https://zhuanlan.zhihu.com/p/20346379?refer=purerender)
</code></pre><a id="more"></a>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><pre><code>利用shouldComponentUpdate 函数
[more](http://imweb.io/topic/577512fe732b4107576230b9)
</code></pre><h2 id="redux-amp-amp-flux"><a href="#redux-amp-amp-flux" class="headerlink" title="redux &amp;&amp; flux"></a>redux &amp;&amp; flux</h2><pre><code>Flux 中是根据不同的功能拆分出多个 store 分而治之
而 Redux 只允许应用中有唯一的 store，通过拆分出多个 reducer 分别管理对应的 state
[more](https://segmentfault.com/a/1190000006769471)

state是应用的状态，一般是一个普通对象，store 是应用状态 state 的管理者
包含下列函数：
    * getState() 获取整个 state
    * dispatch(action)  **触发 state 改变的唯一途径**
    * subscribe(listener)，类似于addEventListener
    * replaceReducer(nextReducer) 一般在 Webpack Code-Splitting 按需加载的时候用
获取state，**state = store.getState()**
一个应用只应有一个单一的 store，其管理着唯一的应用状态 state，不能直接修改应用的状态 state

若要修改state **必须 dispatch 一个 action**

生成store，**createStore**

**Action**
action（动作）实质上是包含 type 属性的普通对象，
 Action Creator是 action 的创造者，本质上就是一个函数，返回值是一个 action（对象），它用于绑定到用户的操作（点击按钮等），其返回值 action 用于之后的 dispatch(action)

**Reducer**
每次 dispatch(action) 后，都会触发 reducer 的执行，reducer 的实质是一个函数，根据 action.type 来更新 state 并返回 nextState
最后会用 reducer 的返回值 nextState 完全替换掉原来的 state

流程：Action Creator =&gt; action =&gt; store.dispatch(action) =&gt; reducer(state, action) =&gt; state = nextState
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Project]]></title>
      <url>http://yoursite.com/2016/08/27/project/</url>
      <content type="html"><![CDATA[<blockquote>
<p> 一些Project的截图，方便查看</p>
</blockquote>
<p>1、doubanMovie<br>仿豆瓣的webApp，实现的功能：</p>
<ul>
<li>用户可以查看 正在上映的电影、豆瓣Top250的电影</li>
<li>用户可以使用 大家都在搜、关键字搜索查找电影</li>
<li>查看导演及其指导电影</li>
<li>电影详情等</li>
<li>用户可以提交反馈等<br><img src="http://o6qp6st9j.bkt.clouddn.com/image/project/movie11.gif" alt="doubanMovie"></li>
</ul>
<a id="more"></a>
<p>2、Frogger Game(使用canvas、观察者模式等)</p>
<ul>
<li>青蛙有5条命，需要越过障碍物通过过马路、河流等到达对岸，有时间限制</li>
<li>游戏会记录玩家的最高分</li>
<li>可以修改时间、帧数等<br><img src="http://o6qp6st9j.bkt.clouddn.com/game.gif" alt="Frogger"></li>
</ul>
<p>3、manageLife</p>
<ul>
<li>用户可以选择登录和不登录</li>
<li>登录后可以保存上次设置的事项，也可以设置一些东西：激励自己的话语等</li>
<li>小卡片之间可以相互移动，卡片间的各项也可以互相移动<br><img src="http://o6qp6st9j.bkt.clouddn.com/image/project/lifeml.gif" alt="manageLife"></li>
</ul>
<p>3、Questions（问卷调查）</p>
<ul>
<li>上传题目并预设好答案</li>
<li>用户答题</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试小记(二)]]></title>
      <url>http://yoursite.com/2016/08/16/arrayQ/</url>
      <content type="html"><![CDATA[<blockquote>
<p>记录在面试过程中遇到的一些编程问题，数组去重、大数据量下的操作等</p>
</blockquote>
<ul>
<li><p>数组去重(连着两次都被问到~)</p>
<ul>
<li><p>O(n^2) 的解法，定义一个变量数组 result 保存结果，遍历需要去重的数组，如果该元素已经存在在 result 中了，则说明是重复的元素，如果没有，则放入 result 中</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*兼容性写法*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result=[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,ilen=arr.length;i&lt;ilen;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> item=arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>,jlen=arr.length;j&lt;jlen;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item == arr[j])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(jlen==j）&#123;</span><br><span class="line">                result.push(item;)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不考虑兼容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result=&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,ilen=arr.length;i&lt;ilen;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> item = arr[i];</span><br><span class="line">        </span><br><span class="line">        (result.indexOf(item)===<span class="number">-1</span>)&amp;&amp;result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result=arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.indexOf(item) === index;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 面试官问我indexOf在数组中可以直接用吗，我当时想indexOf不就是array自带</span><br><span class="line">    的方法吗，后来才想到面试官可能想说的是indexOf的兼容性，还有面试官说indexOf最早是string上的方法</span><br><span class="line">***/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>sort()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.sort().filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !index || item != array[index - <span class="number">1</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object做hash</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(item) ? <span class="literal">false</span> : (obj[item] = <span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>海量数据下Top K的问题</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试小记]]></title>
      <url>http://yoursite.com/2016/08/07/interviewQ/</url>
      <content type="html"><![CDATA[<blockquote>
<p>记录在面试过程中被问到的一些问题，ps:面试真心是一个很好的学习机会，能看到好多自己的不足~~</p>
</blockquote>
<ul>
<li><p>浅拷贝&amp;&amp;深拷贝<br>  浅拷贝会使的两个对象指向同一个内存地址，深拷贝则会开辟一块新的内存空间，然后将被复制对象的属性逐个复制，复制对象不会对被复制对象产生影响。</p>
<ul>
<li><p>浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;  </span><br><span class="line">    F.prototype = obj;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newObj=&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(attr <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        newObj[attr]=obj[attr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*最简单的实现</span><br><span class="line">* 抛弃对象的constructor，RegExp等对象无法复制</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">*这个函数可以实现数组等的深拷贝，不过还是有一些bug</span><br><span class="line">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">extendDeeply</span>(<span class="params">superObj, subObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> subObj = subObj || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(prop <span class="keyword">in</span> superObj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> superObj[prop] == <span class="string">"object"</span>) &#123;</span><br><span class="line">            superObj[prop] = (superObj[prop].construtor === Arrar) ? [] : &#123;&#125;;</span><br><span class="line">            extendDeeply(superObj[prop], superObj[prop]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            subObj[prop] = superObj[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现比较完整的深拷贝，可以参考<a href="http://jerryzou.com/posts/dive-into-deep-clone-in-javascript/" target="_blank" rel="external">http://jerryzou.com/posts/dive-into-deep-clone-in-javascript/</a></p>
<a id="more"></a></li>
</ul>
</li>
<li><p>get/post<br>  GET一般用于获取/查询资源信息，而POST一般用于更新资源信息，根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的</p>
<ul>
<li>Get请求的数据限制(2KB)：URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。</li>
<li>理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，起限制作用的是服务器的处理程序的处理能力</li>
<li>在客户端， Get 方式在通过 URL 提交数据，数据 在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。</li>
<li>浏览器中GET 请求可被缓存。GET 请求保留在浏览器历史记录中</li>
<li>对资源的增，删，改，查操作，其实都可以通过GET/POST完成</li>
</ul>
</li>
<li><p>浏览器渲染流程<br>  <a href="http://cherishsdan.github.io/2016/07/03/eDom/" target="_blank" rel="external">渲染</a></p>
</li>
<li><p>了解webkit吗（如实的回答了，没看过源码，内部机制不是很了解）<br>  该看看这本书了《webkit技术内幕》</p>
</li>
<li><p>数组去重</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.indexOf(item) === index;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ES6 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CDN(问了全称，还好记得~)</p>
<p>  CDN的全称是Content Delivery Network，即内容分发网络。其通过在用户和服务器之间增加Cache层，将网站的内容发布到最接近用户的网络的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度<br>CDN简单的来说就是存储一些静态文件的一台或多台服务器，通过复制，缓存等方式，将文件保存其中。<br>CDN主要是通过接管DNS实现,将用户的请求引导到Cache上获得源服务器的数据。（智能调度DNS是CDN服务中的关键系统.当用户访问加入CDN服务的网站时，域名解析请求将最终由 智能调度DNS 负责处理.）<br>对于普通的Internet用户，每个CDN节点就相当于一个放置在它周围的网站服务器.<br>通过对dns的接管，用户的请求被透明地指向离他最近的节点，节点中CDN服务器会像网站的原始服务器一样，响应用户的请求.<br>参考：<a href="http://cndefu.blog.163.com/blog/static/593931882011422115513240/" target="_blank" rel="external">http://cndefu.blog.163.com/blog/static/593931882011422115513240/</a></p>
</li>
<li><p>类型转换</p>
<blockquote>
<p>举例说明js强制类型转换、隐式类型转换（PS：当时有点蒙，没反应过来强制类型转换指的啥，还好后面反应过来是Number()之类的）</p>
</blockquote>
<p>  先列几个类型转换中的常用技巧：<br>  x+’’   等价于 String(x)<br>  +x     等价于 Number(x)<br>  !!x    等价于 Boolean(x)</p>
<ul>
<li>强制类型转换<br>  指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。</li>
<li><p>隐式类型转换<br>  以 * - + 来说，会对非数值应用Number()转型函数转换</p>
<ul>
<li>Boolean true-1 false-0</li>
<li>null-0</li>
<li>undefined NaN</li>
<li>字符串<br>数字转换为十进制数值<br>十六进制转换为相同大小的十进制<br>空字符串转换为0<br>剩下的转换为NaN</li>
<li>对象 调用valueOf()方法，在依照上述规则，如果转为结果为NaN则调用对象的toString()方法</li>
</ul>
</li>
<li><p>以==操作符来说：</p>
<ul>
<li>String == Boolean，需要两个操作数同时转为Number</li>
<li>String/Boolean == Number，需要String/Boolean转为Number</li>
<li>Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法</li>
<li>undefined == null</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="http://cookfront.github.io/2015/11/09/javascript-types/" target="_blank" rel="external">类型检测</a></p>
</li>
<li><p>ajax</p>
</li>
</ul>
<blockquote>
<p>问了jquery的ajax实现，还有对json的处理，跨域</p>
</blockquote>
<ul>
<li><p>输入框只读<br>readonly</p>
</li>
<li><p>数组相关问题</p>
</li>
</ul>
<blockquote>
<p>这个问题每次都会被问到，特别是数组去重，还有注意ES5的兼容</p>
</blockquote>
<ul>
<li><p>布局(左定宽，右自动)<br>  这个自己做过很多，所以答得还比较全</p>
</li>
<li><p>类型判断</p>
</li>
<li>后端修改数据，浏览器实时更新</li>
</ul>
<hr>
<p>一天面了3面，前两轮都是技术面，第二轮要求手写代码，第三轮是hr面，最后还有一个Boss面</p>
<ul>
<li>angularJS<br>  路由原理，指令的执行过程，依赖注入的目的，与angularJS2的对比，它的MVVM之间的通信、与别的的框架VueJS/ReactJS对比，什么情况下不用双向数据绑定</li>
<li>restful API</li>
<li>闭包</li>
<li>ES6</li>
<li>写代码（排序、迭代Fabonacci）</li>
<li>hr面有会问一些逻辑题</li>
</ul>
<p>最后的Boss面，问了一些逻辑题，还有喜欢看的书，感觉公司比较注重员工的学习习惯还有学习态度</p>
<hr>
<p>一面非常细，面了一个多小时、js、Html5 、css都有问到，比较基础</p>
<p>二面 主要问了项目</p>
<p>三面 综合面，面试官人很好 ps：声音好好听啊，很年轻~<br>等待13号的笔试，求保佑~~<br>等结果中~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[web安全]]></title>
      <url>http://yoursite.com/2016/08/04/websafe/</url>
      <content type="html"><![CDATA[<blockquote>
<p>对web 安全的一些笔记~</p>
</blockquote>
<ul>
<li><p>XSS<br>  本质上是一种注入攻击，简单的说就是利用各种手段把恶意代码添加到网页中，并让受害者执行这段脚本。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</p>
<a id="more"></a>
<p>  主要有以下2种：</p>
<ul>
<li>反射型XSS(过表单GET提交等方式出现在URL中，这些恶意脚本作为输入提交到服务器端，最后返回给浏览器执行。之所以叫做反射型是因为这种攻击方式只生效在本次提交、渲染，下次攻击需要再次提交脚本代码)</li>
<li>存储型XSS(提交的脚本代码会被存储在服务器端数据库、文件系统等地方，每次页面被访问都会被调用、执行)</li>
<li><p>DOM型XSS(不需要服务器端参与，只需要客户端进行DOM解析)</p>
<p>防范：永远不相信用户的输入。</p>
</li>
<li>何时候都不要把不受信任的数据直接插入到dom中的任何位置,一定要做转义。 </li>
<li>使用JSON.parse 而不是eval,request 的content-type要指定是Content-Type: application/json;</li>
<li>CSP(Content Security Policy)</li>
<li>X-Frame-Options</li>
<li>Http-Only</li>
</ul>
</li>
<li><p>CSRF<br>  可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作<br>  利用的是网站服务器端所有参数都是可预先构造的原理，然后黑客拼接好具体URL，<br>  以任何方式去调用你的被攻击网站的接口。</p>
<p>  防范：</p>
<ul>
<li>验证 HTTP Referer(记录了该 HTTP 请求的来源地址)<br>因为在通常情况下，访问一个安全受限页面的请求来自于同一个网站。</li>
<li>在请求中放入黑客所不能伪造的信息 <a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="external">more</a></li>
</ul>
</li>
<li><p>DNS劫持</p>
</li>
<li>http劫持 <a href="http://jixianqianduan.com/frontend-weboptimize/2016/03/20/web-security-and-https.html" target="_blank" rel="external">more</a></li>
</ul>
<p>参考：<br><a href="https://segmentfault.com/a/1190000003852910?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">https://segmentfault.com/a/1190000003852910?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端性能优化——图片]]></title>
      <url>http://yoursite.com/2016/07/21/ePic/</url>
      <content type="html"><![CDATA[<blockquote>
<p>性能优化系列笔记，提升用户体验</p>
</blockquote>
<p>图片内容占互联网内容总量的比例是非常大的，有一半多的流量和时间都用来下载图片，所以，图片是性能优化的重点。<br><a id="more"></a></p>
<ul>
<li><p>图片格式比较</p>
<ul>
<li>JPEG 真彩色、有损压缩，不支持透明度及动画，适用于复杂颜色及形状、尤其是照片。其压缩算法可以精确控制压缩比，以图像质量换得存储空间。</li>
<li>GIF 只支持 256 种颜色、透明通道只有 1 bit、文件压缩比不高。它唯一的优势就是支持多帧动画</li>
<li>PNG 有几种子类型（PNG8、PNG24、PNG32），无损压缩，支持alpha透明，不支持动画<ul>
<li>PNG-8能够显示256种颜色，但能够同时支持256阶透明，因此颜色数较少但需要半透明的情景（如微信动画大表情）可以考虑PNG-8</li>
<li>PNG-24可以显示真彩色，但不支持透明，颜色丰富的图片推荐使用（如屏幕截图、界面设计图）</li>
<li>PNG-32可以显示真彩色，同时支持256阶透明，效果最好但尺寸也最大</li>
</ul>
</li>
<li>webP 用 VP8 视频帧内编码作为其算法基础，支持有损与无损压缩、Alpha 透明以及动画，优势体现在它具有更优的图像数据压缩算法，<a href="https://isux.tencent.com/introduction-of-webp.html" target="_blank" rel="external">more</a></li>
<li>APNG 旨在替换掉画质低劣的 GIF 动画。它实际上只是相当于 PNG 格式的一个扩展</li>
<li>BPG 一款超高压缩比的图片格式，使用 HEVC (即 H.265) 帧内编码作为其算法基础，同等体积下 BPG 能提供更高的图像质量。另外，得益于它本身基于视频编码算法的特性，它能以非常小的文件体积保存多帧动画</li>
<li><p>SVG 无损压缩，支持透明度及动画，适应于简单图形，需要良好的放缩体验<br>需要动态控制图片特效</p>
<p><a href="http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/" target="_blank" rel="external">移动端的支持</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>优化<br>  <img src="http://o6qp6st9j.bkt.clouddn.com/images/effective/ePic.png" alt="ePic"></p>
<p>  dataURL<br>  对于极小的图片可以使用DataURL，除非在尽快要求展现的时候使用，其他时候应该避免使用，因为它在移动端的性能非常差</p>
<p>  标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）</p>
</li>
</ul>
<p><a href="http://www.jianshu.com/p/dc5fd46ff22c" target="_blank" rel="external">图片的延迟加载</a><br><a href="http://www.jianshu.com/p/235ef450f5e9" target="_blank" rel="external">图片响应式处理方案</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[继承]]></title>
      <url>http://yoursite.com/2016/07/17/super/</url>
      <content type="html"><![CDATA[<blockquote>
<p>《javascript 高级程序设计》——继承</p>
</blockquote>
<p>JavaScript 不包含传统的类继承模型，而是使用 prototype 原型模型,使用原型链的继承方式。</p>
<p>prototype和length是每一个函数类型自带的两个属性，prototype属性是一个指针，指向它的原型对象。<br>原型对象内部也有一个指针（constructor属性）指向构造函数:Person.prototype.constructor = Person;<br>Js中的所有对象（undefined、null等特殊情况除外）都有一个内置的[[Prototype]]属性，指向它“父类”的prototype，这个内置属性在ECMA标准中并没有给出明确的获取方式，但是许多Js的实现（如Node、大部分浏览器等）都提供了一个<strong>proto</strong>属性来指代这一[[Prototype]]，ES5中增加了一个方法，Object.getPrototypeOf(),返回<em>proto</em>的值</p>
<p>JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p>
<a id="more"></a>
<ul>
<li>原型链<blockquote>
<p>重写原型对象，代之以一个新类型的实例</p>
</blockquote>
</li>
</ul>
<p>原型链：原型链的形成真正是靠<strong>proto</strong>，在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSubValue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">SuperType.prototype</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:SubType,</span><br><span class="line">    _proto_:Object.prototype</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prototype是函数对象上预设的对象属性，原型是对象上的原型，指向构造器的prototype 属性</p>
<p>注意instance.constructor现在指向的是SuperType<br>通过原型链实现继承的时候，不能使用对象字面量创建原型方法</p>
<p><strong>原型链的问题</strong><br>最主要的问题来自包含引用类型值的原型。包含引用类型的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上回变成另一个类型的实例。于是，原先的实例属性也就变成了原型的属性。<br>在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
<ul>
<li><p>借用构造函数<br>在子类型的构造函数内部调用超类型构造函数</p>
</li>
<li><p>组合继承</p>
</li>
</ul>
<blockquote>
<p>将原型链和借用构造函数的技术组合在一起，使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x += x;</span><br><span class="line">    <span class="keyword">this</span>.y += y;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">"Shape moved."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle - subclass</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>); <span class="comment">//call super constructor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle.prototype = <span class="keyword">new</span> Shape();</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line">rect <span class="keyword">instanceof</span> Rectangle <span class="comment">//true.</span></span><br><span class="line">rect <span class="keyword">instanceof</span> Shape <span class="comment">//true.</span></span><br><span class="line"></span><br><span class="line">rect.move(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">//Outputs, "Shape moved."</span></span><br></pre></td></tr></table></figure>
<p>组合式继承是js最常用的继承模式，但组合继承的超类型在使用过程中会被调用两次；一次是创建子类型的时候，另一次是在子类型构造函数的内部</p>
<ul>
<li>原型式继承(ES5 新增了Object.create()规范了原型式继承)</li>
<li>寄生式继承</li>
<li><p>寄生组合式继承</p>
</li>
<li><p>最有效的继承方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x += x;</span><br><span class="line">    <span class="keyword">this</span>.y += y;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">"Shape moved."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle - subclass</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>); <span class="comment">//call super constructor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line">rect <span class="keyword">instanceof</span> Rectangle <span class="comment">//true.</span></span><br><span class="line">rect <span class="keyword">instanceof</span> Shape <span class="comment">//true.</span></span><br><span class="line"></span><br><span class="line">rect.move(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">//Outputs, "Shape moved."</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Polyfill</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create != <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Temp</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> hasOwn = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">O</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> O != <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'Object prototype may only be an Object or null'</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Temp.prototype = O;</span><br><span class="line">      <span class="keyword">var</span> obj = <span class="keyword">new</span> Temp();</span><br><span class="line">      Temp.prototype = <span class="literal">null</span>; </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Object.defineProperties does ToObject on its first argument.</span></span><br><span class="line">        <span class="keyword">var</span> Properties = <span class="built_in">Object</span>(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> Properties) &#123;</span><br><span class="line">          <span class="keyword">if</span> (hasOwn.call(Properties, prop)) &#123;</span><br><span class="line">            obj[prop] = Properties[prop];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>总结一下继承实现方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* method 1 缺点： 父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改</span><br><span class="line">创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置*/</span></span><br><span class="line">Rectangle.prototype = <span class="keyword">new</span> Shape();</span><br><span class="line"></span><br><span class="line"><span class="comment">// method 2 缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类</span></span><br><span class="line">Rectangle.prototype = Shape.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// method 3 需要兼容性</span></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line"></span><br><span class="line">Rectangle.prototype.area = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line">**在子类构造函数中调用父类构造函数实现实例属性初始化**</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>); <span class="comment">//call super constructor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//polyfill</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">'function'</span>) &#123;</span><br><span class="line"> <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">o, props</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span>(props) === <span class="string">"object"</span>) &#123;</span><br><span class="line">   <span class="keyword">for</span> (prop <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.hasOwnProperty((prop))) &#123;</span><br><span class="line">     F[prop] = props[prop];</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>hasOwnProperty<br>为了判断一个对象是否包含自定义属性而不是原型链上的属性， 我们需要使用继承自 Object.prototype 的 hasOwnProperty 方法。<br>hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。</p>
</li>
<li><p>确定原型与实例的关系<br>instanceof<br>isPrototypeOf() </p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[visibility]]></title>
      <url>http://yoursite.com/2016/07/15/visibility/</url>
      <content type="html"><![CDATA[<p>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;<br>Page Visibility API，主要有三部分组成:</p>
<ul>
<li>document.hidden：表示页面是否隐藏的布尔值。页面隐藏包括 页面在后台标签页中 或者 浏览器最小化</li>
<li>document.visibilityState：表示下面 4 个可能状态的值<ul>
<li>hidden：页面在后台标签页中或者浏览器最小化</li>
<li>visible：页面在前台标签页中</li>
<li>prerender：页面在屏幕外执行预渲染处理 document.hidden 的值为 true</li>
<li>unloaded：页面正在从内存中卸载<a id="more"></a></li>
</ul>
</li>
<li>Visibilitychange 事件：当文档从可见变为不可见或者从不可见变为可见时，会触发该事件  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> isHidden = <span class="built_in">document</span>.hidden;</span><br><span class="line"><span class="keyword">if</span> (isHidden) &#123;</span><br><span class="line"><span class="comment">// 动画停止</span></span><br><span class="line"><span class="comment">// 服务器轮询停止 等等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 动画开始</span></span><br><span class="line"><span class="comment">// 服务器轮询</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">-----------</span><br><span class="line"><span class="comment">//兼容性写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> hidden = <span class="string">"hidden"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Standards:</span></span><br><span class="line"><span class="keyword">if</span> (hidden <span class="keyword">in</span> <span class="built_in">document</span>)</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"visibilitychange"</span>, onchange);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((hidden = <span class="string">"mozHidden"</span>) <span class="keyword">in</span> <span class="built_in">document</span>)</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"mozvisibilitychange"</span>, onchange);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((hidden = <span class="string">"webkitHidden"</span>) <span class="keyword">in</span> <span class="built_in">document</span>)</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"webkitvisibilitychange"</span>, onchange);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((hidden = <span class="string">"msHidden"</span>) <span class="keyword">in</span> <span class="built_in">document</span>)</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"msvisibilitychange"</span>, onchange);</span><br><span class="line"><span class="comment">// IE 9 and lower:</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"onfocusin"</span> <span class="keyword">in</span> <span class="built_in">document</span>)</span><br><span class="line">    <span class="built_in">document</span>.onfocusin = <span class="built_in">document</span>.onfocusout = onchange;</span><br><span class="line"><span class="comment">// All others:</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">window</span>.onpageshow = <span class="built_in">window</span>.onpagehide</span><br><span class="line">    = <span class="built_in">window</span>.onfocus = <span class="built_in">window</span>.onblur = onchange;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onchange</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="string">"visible"</span>, h = <span class="string">"hidden"</span>,</span><br><span class="line">        evtMap = &#123;</span><br><span class="line">        focus:v, focusin:v, pageshow:v, blur:h, focusout:h, pagehide:h</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    evt = evt || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">if</span> (evt.type <span class="keyword">in</span> evtMap)</span><br><span class="line">     <span class="built_in">document</span>.body.className = evtMap[evt.type];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">document</span>.body.className = <span class="keyword">this</span>[hidden] ? <span class="string">"hidden"</span> : <span class="string">"visible"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the initial state (but only if browser supports the Page Visibility API)</span></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">document</span>[hidden] !== <span class="literal">undefined</span> )</span><br><span class="line">    onchange(&#123;type: <span class="built_in">document</span>[hidden] ? <span class="string">"blur"</span> : <span class="string">"focus"</span>&#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端知识杂记——javascript]]></title>
      <url>http://yoursite.com/2016/07/14/note2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>对前端开发知识的一些梳理,主要参考<a href="https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md" target="_blank" rel="external">前端开发面试题</a>及对它的补充，持续完善…</p>
</blockquote>
<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><ul>
<li>基本数据类型<br>   Undefined、Null、Boolean、Number、String、Symbol(ES6)</li>
<li><p>内置对象<br>  Object 是 JavaScript 中所有对象的父对象</p>
<p>  数据封装类对象：Object、Array、Boolean、Number 和 String<br>  其他对象：Function、Arguments、Math、Date、RegExp、Error</p>
<a id="more"></a></li>
<li><p>JavaScript有几种类型的值<br>  栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br>堆：引用数据类型（对象、数组和函数）</p>
<p>  两种类型的区别是：存储位置不同；<br>  原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其<br>在栈中的地址，取得地址后从堆中获得实体</p>
</li>
<li><a href="http://cherishsdan.github.io/2016/07/17/super/" target="_blank" rel="external">继承</a></li>
<li><a href="http://blog.rainy.im/2015/07/20/prototype-chain-in-js/" target="_blank" rel="external">原型</a></li>
<li>创建对象<ul>
<li>对象字面量的方式 </li>
<li>工厂函数</li>
<li>原型链</li>
</ul>
</li>
<li><a href="http://blog.rainy.im/2015/07/04/scope-chain-and-prototype-chain-in-js/" target="_blank" rel="external">作用域链</a></li>
<li>This对象：引用的是函数据以执行的环境对象<ul>
<li>全局范围内:指向全局对象</li>
<li>函数调用:<code>foo()</code> 指向全局对象</li>
<li>方法调用:<code>test.foo();</code>this 指向 test 对象。</li>
<li>调用构造函数:this 指向新创建的对象</li>
<li>显式的设置 this:apply,call</li>
</ul>
</li>
<li><p>null，undefined<br>  null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。<br>  当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p>
<p>  undefined表示”缺少值”<br>  （1）变量被声明了，但没有赋值时，就等于undefined。<br>  （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>  （3）对象没有赋值的属性，该属性的值为undefined。<br>  （4）函数没有返回值时，默认返回undefined。<br>  null表示”没有对象”，即该处不应该有值<br>  （1） 作为函数的参数，表示该函数的参数不是对象。<br>  （2） 作为对象原型链的终点。</p>
</li>
<li>attribute和property<br>  attribute是dom元素在文档中作为html标签拥有的属性；<br>  property就是dom元素在js中作为对象拥有的属性。<br>  对于html的标准属性来说，attribute和property是同步的，是会自动更新的，<br>  但是对于自定义的属性来说，他们是不同步的，</li>
<li>window，document<ul>
<li>DOM,文档对象模型,针对 HTML 和 XML 提供的一个API,以编程的方法操作HTML 的内容</li>
<li>document,是整个 DOM 树的根节点，是window对象的一个属性。这个 document 包含了标题（document.title）、URL（document.URL）等属性，可以直接在 JS 中访问到,在一个浏览器窗口中可能有多个 document，例如，通过 iframe 加载的页面，每一个都是一个 document。</li>
<li>BOM 浏览器对象模型,为了操作浏览器出现的 API。</li>
<li>window 是 BOM 的一个对象,通过这个对象可以获取窗口位置、确定窗口大小、弹出对话框等等</li>
</ul>
</li>
<li><a href="http://www.cnblogs.com/hustskyking/p/problem-javascript-event.html" target="_blank" rel="external">事件机制</a></li>
<li><p>use strict<br>  use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,</p>
<p>  使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。<br>  默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;<br>  全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；<br>  消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;</p>
</li>
<li><p>new操作符<br>   1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>   2、属性和方法被加入到 this 引用的对象中。<br>   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure>
</li>
<li><p>js延迟加载</p>
<ul>
<li>使用script标签的defer(HTML4)和async(HTML5)属性<br>  defer延迟加载脚本,该属性使得浏览器能延迟脚本的执行，等文档完成解析完成后会按照他们在文档出现顺序再去下载解析.在DOMContentLoaded事件之前执行完成。也就是说defer属性script就类似于将script放在body的效果.<br>  而async属性能够异步的加载和执行脚本，不因为加载脚本而阻塞页面的加载。一旦加载到就会立刻执行。在window的load事件之前执行完成</li>
<li><p>动态创建DOM方式<br>  谷歌推荐的代码：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">downloadJSAtOnload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    element.src = <span class="string">"defer.js"</span>;</span><br><span class="line">    element.async = <span class="literal">true</span>;<span class="comment">//可以再Opera和旧版本的FF中支持异步加载</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener)</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, downloadJSAtOnload, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent)</span><br><span class="line">    <span class="built_in">window</span>.attachEvent(<span class="string">"onload"</span>, downloadJSAtOnload);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">window</span>.onload = downloadJSAtOnload;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过ajax下载js脚本(无法引用使用CDN方式提供的js文件)</p>
</li>
</ul>
</li>
<li><a href="http://javascript.ruanyifeng.com/bom/ajax.html" target="_blank" rel="external">Ajax</a><br>  (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.<br>  (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.<br>  (3)设置响应HTTP请求状态变化的函数.<br>  (4)发送HTTP请求.<br>  (5)获取异步调用返回的数据.<br>  (6)使用JavaScript和DOM实现局部刷新.</li>
<li><a href="http://cherishsdan.github.io/2016/05/28/Cors/" target="_blank" rel="external">跨域</a></li>
<li><a href="http://cherishsdan.github.io/2016/06/10/moudle/" target="_blank" rel="external">模块化开发</a></li>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript6</a></li>
<li>document.write，innerHtml<br>  document.write只能重绘整个页面<br>  innerHTML可以重绘页面的一部分</li>
<li><p>offsetWidth</p>
<blockquote>
<p><strong>clientHeight</strong>和<strong>clientWidth</strong>用于描述元素内尺寸，是指 元素内容+内边距 大小，不包括边框（IE下实际包括）、外边距、滚动条部分<br><strong>offsetHeight</strong>和<strong>offsetWidth</strong>用于描述元素外尺寸，是指 元素内容+内边距+边框，不包括外边距和滚动条部分<br><strong>clientTop</strong>和<strong>clientLeft</strong>返回内边距的边缘和边框的外边缘之间的水平和垂直距离，也就是左，上边框宽度<br><strong>offsetTop</strong>和<strong>offsetLeft</strong>表示该元素的左上角（边框外边缘）与已定位的父容器（offsetParent对象）左上角的距离<br><strong>offsetParent</strong>对象是指元素最近的定位（relative,absolute）祖先元素，递归上溯，如果没有祖先元素是定位的话，会返回null<br>  ＞<strong>scrollWidth</strong>和<strong>scrollHeight</strong>是元素的内容区域加上内边距加上溢出尺寸，当内容正好和内容区域匹配没有溢出时，这些属性与clientWidth和clientHeight相等<br>  ＞<strong>scrollLeft</strong>和<strong>scrollTop</strong>是指元素滚动条位置，它们是可写的</p>
</blockquote>
</li>
<li><p><a href="http://www.w3cplus.com/javascript/javascript-hoisting-in-details.html" target="_blank" rel="external">作用域与变量声明提升</a></p>
</li>
<li><p>getComputedStyle<br>  <strong>getComputedStyle</strong>是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，<strong>只读</strong>。<br>  vs element.style<br>  getComputedStyle方法是只读的，只能获取样式，不能设置；而<strong>element.style</strong>能读能写<br>  getComputedStyle方法获取的是最终应用在元素上的所有CSS属性对象,element.style只能获取元素style属性中的CSS样式<br>  element.currentStyle返回的是元素当前应用的最终CSS属性值（包括外链CSS文件，页面中嵌入的<style>属性等,从作用上将，getComputedStyle方法与currentStyle属性走的很近，形式上则style与currentStyle走的近<br>  <code>(element.currentStyle? element.currentStyle : window.getComputedStyle(element, null)).height</code></p>
</li>
<li><p>高性能的Javascript</p>
</li>
<li>cookie&amp;&amp;session<ul>
<li>cookie<br>服务器向客户端发送 cookie，通常使用 HTTP 协议规定的 set-cookie 头操作( cookie 的格式为 name = value)<br>浏览器将 cookie 保存<br>每次请求浏览器都会将 cookie 发向服务器<br>其他可选的 cookie 参数:<br>path:cookie 影响到的路径，匹配该路径才发送这个 cookie<br>secure:当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效<br>expires 和 maxAge:告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 相对时间。当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。<br>httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。</li>
<li>session<br>session 中的数据是保留在服务器端的,通过一个 session_id(express中是connect.sid)来进行。session_id 通常是存放在客户端的 cookie 中.当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改。<br>session 可以存放在 1）内存、2）cookie本身、3）redis 或 memcached 等缓存中，或者4）数据库中</li>
</ul>
</li>
<li>内存泄漏</li>
<li>jquery实现原理</li>
<li>jQuery.fn的init方法返回的this指的是什么对象</li>
<li>extend的实现原理</li>
<li>jquery.extend  jquery.fn.extend</li>
<li>jQuery 的队列</li>
<li>bind(),live(),delegate(),on()</li>
<li>JQuery一个对象可以同时绑定多个事件，这是如何实现的</li>
<li>fire函数、自定义事件</li>
<li>jQuery 是通过哪个方法和 Sizzle 选择器结合的</li>
<li>jQuery性能的优化</li>
<li>Jquery与jQuery UI </li>
<li>jquery 中如何将数组转化为json字符串，然后再转化回来</li>
<li>jQuery和Zepto</li>
<li>Zepto的点透问题</li>
<li>jQueryUI如何自定义组件</li>
<li>移动端最小触控区域</li>
<li>移动端的点击事件的延迟</li>
<li>route, middleware, cluster, nodemon, pm2, server-side rendering</li>
<li>前端路由适用场景、优点和缺点</li>
<li>测试前端代码、BDD, TDD, Unit Test、mocha, sinon, jasmin, qUnit</li>
<li>前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用</li>
<li>js实现千位分隔符</li>
<li>检测浏览器版本</li>
<li><a href="https://segmentfault.com/a/1190000004623125">CSRF XSS</a></li>
</ul>
</style></p></li></ul>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Containing block]]></title>
      <url>http://yoursite.com/2016/07/14/containing-block/</url>
      <content type="html"><![CDATA[<p>在 CSS2.1 中，很多框的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，被称作是包含块( containing block )。 一般来说，(元素)生成的框会扮演它子孙元素包含块的角色，我们称之为：一个(元素的)框为它的子孙节点建造了包含块。包含块是一个相对的概念。<br><a id="more"></a><br>对于一个元素的包含块的定义如下:</p>
<ol>
<li>根元素存在的包含块称为初始包含块<ul>
<li>在(X)HTML中，根元素是html元素</li>
<li>初始包含块的direction属性与根元素相同。(direction属性指定了块的基本书写方向，它还规定了表格列布局的方向、水平溢出的方向等。)</li>
<li>初始包含块的宽度可以由根元素的width属性指定。如果该属性取值为“auto”，用户端提供初始宽度（如，视口的当前宽度）</li>
<li>初始包含块的高度可以由根元素的height属性指定。如果该属性取值为“auto”，包含块的高度将调整以适应文档内容（即由其内容决定其高度）。</li>
<li>初始包含块的高度可以由根元素的height属性指定。如果该属性取值为“auto”，包含块的高度将调整以适应文档内容（即由其内容决定其高度）。</li>
</ul>
</li>
<li>对于其它元素：如果该元素的定位（position）为“relative（相对）”或者“static（静态）”，它的包含块由它最近的块级、单元格（table cell）或者行内块（inline-block）祖先元素的内容区创建。</li>
<li>如果一个元素’position’为’fixed’，那么其包含块为当前屏幕的可视窗口</li>
<li>如果一个元素的’position’为’absolute’，那么其包含块则是最近的’position’为’relative’ 或’absolute’或 ‘fixed’的祖先元素,有如下几种情况：<ul>
<li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的 “direction” 特性</li>
<li>其他情况下，如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界。<br><img src="http://www.smallni.com/wp-content/uploads/2012/03/CB4.png" alt="containing"></li>
</ul>
</li>
</ol>
<p>例如<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>div的包含快为body，若为div设定<code>position: absolute</code>,则它的包含快为初始包含快</p>
<p>参考：<br><a href="http://www.ddcat.net/blog/?p=1336" target="_blank" rel="external">http://www.ddcat.net/blog/?p=1336</a><br><a href="http://www.smallni.com/containing-block/" target="_blank" rel="external">http://www.smallni.com/containing-block/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Html5 离线存储]]></title>
      <url>http://yoursite.com/2016/07/13/manifest/</url>
      <content type="html"><![CDATA[<p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件<br>为了让web应用程序在离线状态下也能正常工作，就必须把构成web应用程序的资源文件，如HTML、CSS、JS脚本文件等放在本地缓存中，当服务器没有和Interne连接时，也可以利用本地缓存中的资源文件来正常运行web程序。<br><a id="more"></a></p>
<ul>
<li>本地缓存&amp;浏览器网页缓存<br>  本地缓存为整个web应用服务，浏览器的网页缓存只服务于单个网页<br>  本地缓存是可靠的，我们可以控制对哪些内容进行缓存，控制缓存的更新。<br>  用户可离线访问应用，这对于无法随时保持联网状态的移动终端用户来说尤其重要<br>  用户访问本地的缓存文件，通常意味着更快的访问速度<br>  仅仅加载被修改过的资源，避免同一资源对服务器多次的请求，大大降低了对服务器的访问压力</li>
</ul>
<ul>
<li><p>manifest文件<br>  <code>&lt;!DOCTYPE HTML&gt;
&lt;html manifest = &quot;cache.manifest&quot;&gt;
...
&lt;/html&gt;</code><br>  web应用程序是通过每个页面的manifest文件来管理的，manifest文件是一个简单文本文件，在该文件中以清单的方式列举了需要被缓存或不需要被缓存的资源文件名称，以及这些资源文件的访问路径(在manifest中使用的相对路径，相对参照物为manifest文件)。可以为每一个文件单独指定一个manifest文件，也可以对整个web应用程序指定一个总的manifest文件。</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"> #v0.11</span><br><span class="line"></span><br><span class="line"> CACHE:</span><br><span class="line"> other.html</span><br><span class="line"> js/app.js</span><br><span class="line"> css/style.css</span><br><span class="line"></span><br><span class="line"> NETWORK:</span><br><span class="line"> http://YIDan/</span><br><span class="line"> resourse/logo.png</span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> FALLBACK:</span><br><span class="line"> / /offline.html</span><br></pre></td></tr></table></figure>
<p>  CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来<br>  2、#号开头的是注释，一般会在第二行写个版本号，用来在缓存的文件更新时，更改manifest的作用，可以是版本号，时间戳或者md5码等等。<br>  3 NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。”*”表示没有在manifest文件中指定的资源文件都不进行本地缓存</p>
<ol>
<li>FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html<br>每个类别都是可选的，当文件开头没有指定类别而直接书写资源文件时，浏览器把这些资源文件视为CACHE类别，直至看见文件中第一个书写出来的类别为止。<br>真正运行离线web应用程序时，需要对服务器进行配置，让服务器支持text/text/cache-manifest这个MIME类型</li>
</ol>
</li>
<li><p>浏览器怎么解析manifest</p>
<ol>
<li>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li>
<li>离线的情况下，浏览器就直接使用离线存储的资源。</li>
</ol>
</li>
</ul>
<p>  有几个问题需要注意：</p>
<ol>
<li>如果服务器对离线的资源进行了更新，那么必须更新manifest文件之后这些资源才能被浏览器重新下载，如果只是更新了资源而没有更新manifest文件的话，浏览器并不会重新下载资源，也就是说还是使用原来离线存储的资源。可以通过修改版本号的方式来让浏览器认为manifest文件已经被更新过了。</li>
<li>对于manifest文件进行缓存的时候需要十分小心，因为可能出现一种情况就是你对manifest文件进行了更新，但是http的缓存规则告诉浏览器本地缓存的manifest文件还没过期，这个情况下浏览器还是使用原来的manifest文件，所以对于manifest文件最好不要设置缓存</li>
<li>浏览器在下载manifest文件中的资源的时候，它会一次性下载所有资源，如果某个资源由于某种原因下载失败，那么这次的所有更新就算是失败的，浏览器还是会使用原来的资源</li>
<li>在更新了资源之后，新的资源需要到下次再打开app才会生效，如果需要资源马上就能生效，那么可以使用window.applicationCache.swapCache()方法来使之生效，出现这种现象的原因是浏览器会先使用离线资源加载页面，然后再去检查manifest是否有更新，所以需要到下次打开页面才能生效。</li>
<li>引用manifest的html必须与manifest文件同源，在同一个域下.FALLBACK中的资源必须和manifest文件同源.当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问</li>
<li>站点离线存储的容量限制是5M</li>
</ol>
<ul>
<li>applicationCache对象<br>  applicationCache对象代表了本地缓存，可以用它来通知用户本地缓存中已经被更新，也允许用户手工更新本地缓存。<br>  当浏览器对本地缓存进行更新，装入新的资源文件时，会触发applicationCache对象的updateready事件，通知本地缓存已被更新。<br>  swapCache用来手工执行本地缓存的更新，swapCache方法的意思是重新应用跟新后的缓存来替换原来的缓存,只能在applicationCache对象的updateready事件被触发时调用。即“本地缓存准备被更新”<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.applicationCache.addEventListener(<span class="string">'updateready'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'updateready!'</span>);</span><br><span class="line">            <span class="built_in">window</span>.applicationCache.swapCache();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>window.applicationCache有几个事件：</p>
<ol>
<li>oncached:当离线资源存储完成之后触发这个事件</li>
<li>onchecking:当浏览器对离线存储资源进行更新检查的时候会触发这个事件</li>
<li>ondownloading:当浏览器开始下载离线资源的时候会触发这个事件</li>
<li>onprogress:当浏览器在下载每一个资源的时候会触发这个事件，每下载一个资源就会触发一次</li>
<li>onupdateready:当浏览器对离线资源更新完成之后会触发这个事件</li>
<li>onnoupdate:当浏览器检查更新之后发现没有资源更新的时候触发这个事件</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浏览器跨标签通讯]]></title>
      <url>http://yoursite.com/2016/07/13/mulitiTab/</url>
      <content type="html"><![CDATA[<p>有这样一个场景，A访问了一个网站，登录后，打开第二个标签页并注销登录，那么第一个标签页应该先判断A是否注销，然后做相应改变。这就涉及到多标签页之间如何通讯<br>有以下几种方法：</p>
<ol>
<li><a href="">SharedWorker</a></li>
<li><p>localstorage<br> 不论其中的哪一项在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件。实际上，这就意味着不论在哪个浏览器的标签页里访问了 localStorage，所有其它的标签页都能通过 window 对象监听到这个事件</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'storage'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(event.key, event.newValue);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 不论某个标签页在何时修改了 localStorage，都会对其余的所有标签触发事件。这就意味着我们只要为 localStorage 赋值，就能够跨浏览器标签通信了。<br> 不过，一些浏览器的仍然存在着 quirks，譬如无痕模式下的 Safari 在设置值时会抛出 QuotaExceededError 的异常，有某些浏览器不支持开箱即用的 JSON,可以使用<a href="https://github.com/bevacqua/local-storage" target="_blank" rel="external">bevacqua local-storage</a></p>
</li>
<li>WebSocket</li>
<li>cookies</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iframe]]></title>
      <url>http://yoursite.com/2016/07/13/iframe/</url>
      <content type="html"><![CDATA[<p>iframe：一个普通的html元素，可以通过css设置样式，是一个inline-block元素</p>
<p>iframe 的页面和父页面（parent）是分开的，所以它意味着，这是一个独立的区域，不受 parent 的 CSS 或者全局的 JavaScript 的影响，在一定程度上，类似于沙箱隔离（sandbox）。<br><a id="more"></a><br>如果要获取iframe中的内容，需要使用document.contentWindow属性，以及contentDocument属性</p>
<ul>
<li>document.contentWindow获取子窗口的window对象，ie、ff、chrome都支持，chrome需要在服务器端才能使用</li>
<li>document.contentDocument 获取子窗口的document对象，（ie6、7不支持）ie8+、ff、chrome支持，chrome需要在服务器端测试<br>通过iframe获取其父容器的window属性，通过window.parent，window.top</li>
<li>window.parent 直接获取父元素的window，如果父元素还是iframe，那就是该iframe的window对象</li>
<li>window.top 获取最顶层的容器的window对象</li>
</ul>
<p><strong>iframe功能</strong></p>
<ol>
<li>用来实现长连接，在websocket不可用的时候作为一种替代 <a href="http://www.ibm.com/developerworks/cn/web/wa-lo-comet/#N10101" target="_blank" rel="external">more</a></li>
<li>跨域通信</li>
<li>历史记录管理，解决ajax化网站响应浏览器前进后退按钮的方案，在HTML5的history api不可用时作为一种替代。</li>
<li>纯前端的utf8和gbk编码互转。比如在utf8页面需要生成一个gbk的encodeURIComponent字符串，可以通过页面加载一个gbk的iframe，然后主页面与子页面通信的方式实现转换，这样就不用在页面上插入一个非常巨大的编码映射表文件了</li>
<li>用iframe实现无刷新文件上传（同域），在FormData不可用时作为替代方案<br>原理：在A页面的表单提交数据到服务器，并且指定target属性为B页面，服务器返回内容到B页面，然后在B页面中调用JavaScript程序，来刷新A页面，完成一次请求。如果在此过程中，B为A页面的一个iframe页面，而且一直不显示，则对用户来说，就是一个无刷新,<a href="https://segmentfault.com/a/1190000004629322" target="_blank" rel="external">more</a></li>
<li>在移动端用于从网页调起客户端应用(此方法在iphone上并不安全，慎用)</li>
<li>创建一个全新的独立的宿主环境,用于隔离或者访问原始接口及对象，比如有些前端安全的防范会覆盖一些原生的方法防止恶意调用，那我们就能通过创建一个iframe，然后从iframe中取回原始对象和方法来破解这种防范</li>
<li>IE6下用于遮罩select</li>
<li>解决加载缓慢的第三方内容如图标和广告等的加载问题</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>搜索引擎的检索程序无法解读这种页面，不利于SEO</li>
<li>会阻塞主页面的Onload事件</li>
<li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载<br>如果需要使用iframe，最好是通过javascript<br>动态给iframe添加src属性值，这样可以绕开以上两个问题</li>
</ol>
<p><strong>iframe自适应</strong><br>参照：<a href="http://caibaojian.com/iframe-adjust-content-height.html" target="_blank" rel="external">http://caibaojian.com/iframe-adjust-content-height.html</a><br><a href="http://www.cnblogs.com/snandy/p/3900016.html" target="_blank" rel="external">http://www.cnblogs.com/snandy/p/3900016.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端知识杂记——CSS]]></title>
      <url>http://yoursite.com/2016/07/10/note1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>对前端开发知识的一些梳理,主要参考<a href="https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md" target="_blank" rel="external">前端开发面试题</a>及对它的补充，持续完善…</p>
</blockquote>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><pre><code>盒模型指定元素如何显示，页面上的每个元素都被看成一个矩形框，这个框由元素的内容、内边距、边框和外边距组成。
内边距出现在元素的周围，如果在元素上添加背景，那么背景就会被应用于内容和内边距组成区域。常常使用内边距在元素周围创建一个隔离带。外边距是透明的，一般使用它控制元素之间的间隔。
CSS3中新增了一种盒模型计算方式：box-sizing熟悉。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下：
{% fi /https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/assets/box-model.svg, box, box %}
&lt;!--more--&gt;
box-sizing属性:控制元素的盒模型的解析模式
 1. content-box(默认)
 让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高
 2. border-box
 让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content
</code></pre><h4 id="属性继承："><a href="#属性继承：" class="headerlink" title="属性继承："></a>属性继承：</h4><pre><code>* 可继承的样式：font-size font-family color, text-indent;
* 不可继承的样式：border padding margin width height;
</code></pre><h4 id="containing-block"><a href="#containing-block" class="headerlink" title="containing block"></a><a href="http://cherishsdan.github.io/2016/07/14/containing-block/" target="_blank" rel="external">containing block</a></h4><h4 id="BFC和haslayout"><a href="#BFC和haslayout" class="headerlink" title="BFC和haslayout"></a><a href="http://cherishsdan.github.io/2016/05/08/BFC/" target="_blank" rel="external">BFC</a>和haslayout</h4><pre><code>Windows上的IE使用布局概念来控制元素的尺寸和定位，“拥有布局”(has layout)的元素负责本身及其子元素的尺寸设置和定位，如果一个元素没有“拥有布局”，那么它的尺寸和位置由最近的拥有布局的祖先元素控制。[more](http://blog.csdn.net/borishuai/article/details/8127758)
</code></pre><h4 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h4><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><pre><code>常用的：
1. none 关闭一个元素的显示（对布局没有影响）；其所有后代元素都也被会被关闭显示。文档渲染时，该元素如同不存在。
2. inline 元素宽度由内容决定，与其他元素并列在一行
3. block 可以设置宽度，独占一行
4. inline-block 宽度可以自行设置，类似block，但是与其他元素共占一行，类似inline。长用于设置垂直居中
5. table-cell 标签元素以表格单元格的形式呈现
[更多](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display)
</code></pre><h4 id="position"><a href="#position" class="headerlink" title="position"></a><a href="http://cherishsdan.github.io/2016/05/20/position/" target="_blank" rel="external">position</a></h4><h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a><a href="http://cherishsdan.github.io/2016/05/01/float/" target="_blank" rel="external">浮动</a></h4><h4 id="visibility"><a href="#visibility" class="headerlink" title="visibility"></a>visibility</h4><pre><code>1. visible:默认值。元素是可见的。
2. hidden:元素是不可见的。会占据页面上的空间
3. collapse:当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 &quot;hidden&quot;。
4.inherit: 规定应该从父元素继承 visibility 属性的值。
</code></pre><p>任何的版本的 Internet Explorer （包括 IE8）都不支持 “inherit” 和 “collapse” 属性值。</p>
<h4 id="position跟display、margin-collapse、overflow、float这些特性相互叠加"><a href="#position跟display、margin-collapse、overflow、float这些特性相互叠加" class="headerlink" title="position跟display、margin collapse、overflow、float这些特性相互叠加"></a><a href="http://www.cnblogs.com/jackyWHJ/p/3756087.html" target="_blank" rel="external">position跟display、margin collapse、overflow、float这些特性相互叠加</a></h4><h4 id="margin和padding使用场景"><a href="#margin和padding使用场景" class="headerlink" title="margin和padding使用场景"></a>margin和padding使用场景</h4><pre><code>1. margin：
需要在border外侧添加空白时
空白处不需要背景（色）时
上下相连的两个盒子之间的空白，需要相互抵消时。如15px + 20px的margin，将得到20px的空白
2. padding
需要在border内测添加空白时
空白处需要背景（色）时。
上下相连的两个盒子之间的空白，希望等于两者之和时。如15px + 20px的padding，将得到35px的空白
margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“呼吸距离”
</code></pre><hr>
<h4 id="外边距叠加"><a href="#外边距叠加" class="headerlink" title="外边距叠加"></a>外边距叠加</h4><pre><code>简单地说，就是两个或多个毗邻（父子元素或兄弟元素）的普通流中的块元素垂直方向上的 margin 会发生叠加。这种方式形成的外边距即可称为外边距叠加
毗邻是指没有被非空内容、padding、border 或 clear 分隔开
margin叠加会发生在2种关系下，一种是父子元素，一种是兄弟元素
* 父子元素（分2种情况）之间发生margin叠加的条件
    1. 父元素和第一个子元素发生margin-top叠加
        * 父元素没有创建BFC
        * 父元素和第一个子元素之间没有非空内容
        * 父元素没有border-top
        * 父元素没有padding-top
    2. 父元素和最后一个子元素发生margin-bottom叠加
        * 父元素没有创建BFC
        * 父元素height为auto、min-height为0
        * 父元素和最后一个子元素之间没有非空内容
        * 父元素没有border-bottom
        * 父元素没有padding-bottom
    解决：为父元素创建BFC
          为父元素设置相应的padding或者border

* 兄弟元素之间发生外边距叠加的条件
    * 兄弟元素都不是float元素
    * 兄弟元素都不是absolute元素
    * 兄弟元素都不是inline-block元素
那么避免：让兄弟元素float、让兄弟元素absolute、让兄弟元素inline-block [more](http://www.smallni.com/collapsing-margin/)
</code></pre><hr>
<h4 id="CSS选择符"><a href="#CSS选择符" class="headerlink" title="CSS选择符"></a>CSS选择符</h4><pre><code>1.id选择器（ # myid）
2.类选择器（.myclassname）
3.标签选择器（div, h1, p）
4.相邻选择器（h1 + p）
5.子选择器（ul &gt; li）
6.后代选择器（li a）
7.通配符选择器（ * ）
8.属性选择器（a[rel = &quot;external&quot;]）
9.伪类选择器（a:hover, li:nth-child）

可继承的样式： font-size font-family color, UL LI DL DD DT;
不可继承的样式：border padding margin width height ;
`
</code></pre><h4 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h4><pre><code>优先级就近原则，同权重情况下样式定义最近者为准;
优先级关系：内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器
属性后插有 !important 的属性拥有最高优先级
以下是权重的规则：：
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">标签及伪元素的权重为1，<span class="selector-tag">class</span>（伪类、属性）的权重为10，<span class="selector-tag">id</span>的权重为100，以下例子是演示各种定义的权重值</span><br><span class="line"><span class="comment">/*权重为1*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*权重为10*/</span></span><br><span class="line"><span class="selector-class">.class1</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*权重为100*/</span></span><br><span class="line"><span class="selector-id">#id1</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*权重为100+1=101*/</span></span><br><span class="line"><span class="selector-id">#id1</span> <span class="selector-tag">div</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*权重为10+1=11*/</span></span><br><span class="line"><span class="selector-class">.class1</span> <span class="selector-tag">div</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*权重为10+10+1=21*/</span></span><br><span class="line"><span class="selector-class">.class1</span> <span class="selector-class">.class2</span> <span class="selector-tag">div</span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="CSS3新增伪类"><a href="#CSS3新增伪类" class="headerlink" title="CSS3新增伪类"></a>CSS3新增伪类</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">:after          在元素之前添加内容,也可以用来做清除浮动。</span><br><span class="line">:before         在元素之后添加内容</span><br><span class="line">:enabled        </span><br><span class="line">:disabled       控制表单控件的禁用状态。</span><br><span class="line">:checked        单选框或复选框被选中。`</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h4><pre><code>1. 各种CSS选择器
2. 圆角  
3. 多列布局
4. 阴影和反射
5. 文字特效
6. 文字渲染
7. 线性渐变
8. 旋转,缩放,定位,倾斜,动画，多背景
</code></pre><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><h4 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h4><hr>
<ul>
<li><p>布局</p>
<ol>
<li><a href="http://www.w3cfuns.com/notes/15972/e7a1555bab4dbd270c64dd9626425b48/page/2.html" target="_blank" rel="external">自适应布局</a></li>
<li><p><a href="https://segmentfault.com/a/1190000004524159" target="_blank" rel="external">圣杯布局</a><br> <a href="http://www.w3cplus.com/css/the-definitive-guide-to-using-negative-margins.html" target="_blank" rel="external">负margin</a><br> <a href="http://blog.qiji.tech/archives/11747" target="_blank" rel="external">双飞翼布局</a><br> 圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。</p>
<p> 不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：<br> 圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。</p>
<p> 双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。<br> 多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，一共6个；而双飞翼布局子div里用margin-left和margin-right共2个属性，6-2=4）(<a href="https://www.zhihu.com/question/21504052/answer/50053054" target="_blank" rel="external">https://www.zhihu.com/question/21504052/answer/50053054</a>)</p>
</li>
<li><a href="https://li-xinyang.gitbooks.io/frontend-notebook/content/chapter4/02_layout.html" target="_blank" rel="external">居中</a></li>
</ol>
</li>
</ul>
<hr>
<h4 id="浏览器的兼容性"><a href="#浏览器的兼容性" class="headerlink" title="浏览器的兼容性"></a><a href="http://cherishsdan.github.io/2016/04/20/browser/" target="_blank" rel="external">浏览器的兼容性</a></h4><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a><a href="http://cherishsdan.github.io/2016/07/21/ePic/" target="_blank" rel="external">图片</a></h4><h4 id="在网页中的应该使用奇数还是偶数的字体"><a href="#在网页中的应该使用奇数还是偶数的字体" class="headerlink" title="在网页中的应该使用奇数还是偶数的字体"></a><a href="https://www.zhihu.com/question/20440679" target="_blank" rel="external">在网页中的应该使用奇数还是偶数的字体</a></h4><h4 id="抽离样式模块"><a href="#抽离样式模块" class="headerlink" title="抽离样式模块"></a>抽离样式模块</h4><p> 我理解的应该是提取页面公共样式。<br>一个项目的CSS可以拆分成2部分：公共CSS和业务CSS。我们在项目中抽出的这部分可以模块化的CSS就可以归类为公共CSS。这部分的代码命名不应涉及到具体的业务，只应对其在模块中负责的具体逻辑负责。<br>可以把网站的字体大小，公共控制，共用模块的样式都抽离出来，作为单独的模块来处理。这样，团队中的每个人如果需要这样的样式，都可以用这种公共样式，以此提高代码的重用率。<br>好的复用模块，应该是完整的、独立的。完整就是包含 PSD 中遇到的各种情况，对于不同的情况，只需要添加不同的类或者改用不同结构即可。独立性就是与其他模块和结构完全独立，直接粘贴复制不会产生任何影响。</p>
<h4 id="全屏滚动"><a href="#全屏滚动" class="headerlink" title="全屏滚动"></a>全屏滚动</h4><h4 id="视觉差"><a href="#视觉差" class="headerlink" title="视觉差"></a><a href="http://www.alloyteam.com/2014/01/parallax-scrolling-love-story/" target="_blank" rel="external">视觉差</a></h4><h4 id="手动写动画最小时间间隔"><a href="#手动写动画最小时间间隔" class="headerlink" title="手动写动画最小时间间隔"></a>手动写动画最小时间间隔</h4><pre><code>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms
</code></pre><h4 id="CSS-预处理器-后处理器"><a href="#CSS-预处理器-后处理器" class="headerlink" title="CSS 预处理器 / 后处理器"></a>CSS 预处理器 / 后处理器</h4><pre><code>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，
</code></pre><p>  还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</p>
<pre><code>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的
</code></pre><p>  是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p>
<h4 id="初始化CSS样式"><a href="#初始化CSS样式" class="headerlink" title="初始化CSS样式"></a>初始化CSS样式</h4><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。<br>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p>
<p>最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议）</p>
<p>淘宝的样式初始化代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">hr</span>, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">li</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">form</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">legend</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">1.5</span>tahoma, arial, \<span class="number">5</span>b8b\<span class="number">4</span>f53; &#125;</span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>&#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125;</span><br><span class="line"><span class="selector-tag">address</span>, <span class="selector-tag">cite</span>, <span class="selector-tag">dfn</span>, <span class="selector-tag">em</span>, <span class="selector-tag">var</span> &#123; <span class="attribute">font-style</span>:normal; &#125;</span><br><span class="line"><span class="selector-tag">code</span>, <span class="selector-tag">kbd</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">samp</span> &#123; <span class="attribute">font-family</span>:couriernew, courier, monospace; &#125;</span><br><span class="line"><span class="selector-tag">small</span>&#123; <span class="attribute">font-size</span>:<span class="number">12px</span>; &#125;</span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123; <span class="attribute">list-style</span>:none; &#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">text-decoration</span>:none; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>:underline; &#125;</span><br><span class="line"><span class="selector-tag">sup</span> &#123; <span class="attribute">vertical-align</span>:text-top; &#125;</span><br><span class="line"><span class="selector-tag">sub</span>&#123; <span class="attribute">vertical-align</span>:text-bottom; &#125;</span><br><span class="line"><span class="selector-tag">legend</span> &#123; <span class="attribute">color</span>:<span class="number">#000</span>; &#125;</span><br><span class="line"><span class="selector-tag">fieldset</span>, <span class="selector-tag">img</span> &#123; <span class="attribute">border</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125;</span><br><span class="line"><span class="selector-tag">table</span> &#123; <span class="attribute">border-collapse</span>:collapse; <span class="attribute">border-spacing</span>:<span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="css优化"><a href="#css优化" class="headerlink" title="css优化"></a><a href="">css优化</a></h4><h4 id="Cookie-隔离"><a href="#Cookie-隔离" class="headerlink" title="Cookie 隔离"></a>Cookie 隔离</h4><p>如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，<br>所以不如隔离开。<br>cookie隔离技术则是通过使用多个非主要域名来请求静态文件<br>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将cookie传入webserver，也减少了webserver对cookie的处理分析环节，提高了webserver的http请求的解析速度。</p>
<hr>
<h4 id="FOUC（无样式内容闪烁）"><a href="#FOUC（无样式内容闪烁）" class="headerlink" title="FOUC（无样式内容闪烁）"></a>FOUC（无样式内容闪烁）</h4><p><code>&lt;style type=&quot;text/css&quot;&gt;@import&quot;../fouc.css&quot;;&lt;/style&gt;</code>而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。解决方法简单的出奇，只要在<head>之间加入一个<link>或者<script>元素就可以了。</p>
</script></head></p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端性能优化——载入]]></title>
      <url>http://yoursite.com/2016/07/05/ejs/</url>
      <content type="html"><![CDATA[<blockquote>
<p>性能优化系列笔记，提升用户体验</p>
</blockquote>
<p>从Yahoo军规到现在各种各样的优化技术，不能一概而论，还是要根据用户需求，<br>制定适合自己的优化方案</p>
<p>载入优化，简单来说，就是重要的同步加载，不重要的异步加载。<br>以FaceBook的BigPipe方案为例，它大概有3步：</p>
<ol>
<li>首屏先同步加载，返回一些占位符</li>
<li>根据需求，请求占位符的资源（ID）</li>
<li>填充占位符</li>
</ol>
<p>不过这种方案也有缺点:</p>
<ol>
<li>SEO 引擎较难抓取</li>
<li>异步请求较多</li>
<li>模块之间相互通信引用</li>
<li>模板引擎渲染</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端知识杂记]]></title>
      <url>http://yoursite.com/2016/07/05/note/</url>
      <content type="html"><![CDATA[<blockquote>
<p>对前端开发知识的一些梳理,主要参考<a href="https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md" target="_blank" rel="external">前端开发面试题</a>及对它的补充，持续完善…</p>
</blockquote>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul>
<li><a href="http://www.cnblogs.com/coco1s/p/3588716.html" target="_blank" rel="external">理解web标准</a></li>
<li><p><strong>浏览器内核</strong><br>  主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<br>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>
<a id="more"></a>
<p>  JS引擎则：解析和执行javascript来实现网页的动态效果。</p>
<p>  最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<p>  <a href="http://web.jobbole.com/84826/" target="_blank" rel="external">更多</a></p>
</li>
<li><p><strong>Doctype</strong><br>  &lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 <html> 标签之前。<br>  这个标签是一种通用标记语言的文档类型声明，它主要就是告诉标准通用标记语言解析器应该使用什么样的文档类型定义 Document Type Definition（DTD）来解析文档。DTD定义了文档中的元素(标记和属性)和实体，以及相互关系。数据和结构分离。 通俗的来说，DTD就是一套关于标记符的语法规则，是html的验证机制。<br>  DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。<br>  <code>&lt;!DOCTYPE HTMLPUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
  &lt;!DOCTYPE html&gt;</code><br>  在HTML4.01中，&lt;!DOCTYPE&gt;声明引用DTD，因为HTML4.01基于标准通用标记语言(SGML)。DTD规定了标记语言的规则，这样浏览器才能正确地呈现内容。<br>  然而现在的HTML5不基于SGML，所以不需要引用DTD，因此没有声明DTD。<br>  总的来说，Doctype的作用就是声明文档的解析类型(document.compatMode),也就是告知浏览器的解析器用什么文档标准解析这个文档。如果DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</html></p>
</li>
<li><strong>页面的渲染模式</strong><br>  页面的渲染模式document.compatMode有两种可能的返回值：BackCompat和CSS1CompatBackCompat：怪异模式（兼容模式），浏览器使用自己的怪异模式解析渲染页面。<br>  CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。<br>  所谓的怪异模式就是没有页面的DOCTYPE声明，标准模式具有DOCTYPE声明。<br>  标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。<br>  在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</li>
<li><strong>元素</strong><br>  行内元素：a b span img input select strong<br>  块级元素：div ul ol li dl dt dd h1~h6 p<br>  空元素: “br hr img input link meta area base col command embed keygen param source track wbr “</li>
<li><strong>link和@import</strong><ol>
<li>导入的语法不相同<br>link （链接式）语法为：<br><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; type=&quot;text/css&quot;/&gt;
@import （导入式）语法为：
&lt;style type=&quot;text/css&quot;&gt;
@import url(&quot;style.css&quot;);
&lt;/style&gt;</code></li>
<li>link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;</li>
<li>加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显</li>
<li>兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。</li>
<li>使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。</li>
<li>@import可以在css中再次引入其他样式表，比如可以创建一个主样式表，在主样式表中再引入其他的样式表</li>
</ol>
</li>
<li><strong>HTML语义化</strong><br>  用正确的标签做正确的事情。<br>  代码更简洁，复用性更高。使用合适的标签，可以少些很多css或者js<br>  html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;<br>  即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;<br>  搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;<br>  使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。<br>  <a href="http://nicolasgallagher.com/about-html-semantics-front-end-architecture/" target="_blank" rel="external">更多</a></li>
<li><p><a href="http://cherishsdan.github.io/2016/07/13/iframe/" target="_blank" rel="external"><strong>iframe</strong></a></p>
</li>
<li><p><a href="http://cherishsdan.github.io/2016/07/13/mulitiTab/" target="_blank" rel="external"><strong>浏览器内多个标签页之间的通信</strong></a></p>
</li>
<li><a href="http://cherishsdan.github.io/2016/07/15/visibility/" target="_blank" rel="external"><strong>页面可见性</strong></a></li>
</ul>
<hr>
<ul>
<li><strong>label</strong><br>  label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上</li>
<li><strong>form关闭自动完成</strong><br>  给不想要提示的 form 或某个 input 设置为 autocomplete=off</li>
<li><p><strong>圆形可点击区域</strong></p>
<ol>
<li><p>area+map</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src =<span class="string">"planets.gif"</span> alt=<span class="string">"Planets"</span> usemap =<span class="string">"#planetmap"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;map id ="planetmap"&gt;</span><br><span class="line">    &lt;area shape ="rect" coords ="0,0,82,126" href ="sun.htm" alt="Sun" /&gt;</span><br><span class="line">    &lt;area shape ="circle" coords ="90,58,3" href ="mercur.htm" alt="Mercury" /&gt;</span><br><span class="line">&lt;area shape ="circle" coords ="124,58,8" href ="venus.htm" alt="Venus" /&gt;</span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>svg</p>
</li>
<li>border-radius</li>
<li>js </li>
</ol>
</li>
</ul>
<ul>
<li>不使用 border 画出1px高的线<br><code>&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</code></li>
<li><p>table&amp;h1 b&amp;strong i&amp;em<br>  title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；</p>
<p>  strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<b>是展示强调内容。</b></strong></p>
<p>  i内容展示为斜体，em表示强调的文本；</p>
<p>  Physical Style Elements – 自然样式标签<br>  b, i, u, s, pre<br>  Semantic Style Elements – 语义样式标签<br>  strong, em, ins, del, code<br>  应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</p>
</li>
<li><p>ie各版本和chrome可以并行下载资源数<br>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个<br>Firefox，chrome也是6个</p>
</li>
</ul>
<hr>
<ul>
<li><p>HTML5新特性</p>
<ul>
<li><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加<br>绘画 canvas;<br>  用于媒介回放的 video 和 audio 元素;<br>  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;<br>  sessionStorage 的数据在浏览器关闭后自动删除;</p>
<p>  语意化更好的内容元素，比如 article、footer、header、nav、section;<br>  表单控件，calendar、date、time、email、url、search;<br>  新的技术webworker, websocket, Geolocation;</p>
</li>
<li><p>移除的元素：<br>纯表现的元素：basefont，big，center，font, s，strike，tt，u;<br>  对可用性产生负面影响的元素：frame，frameset，noframes；<br>可以使用 html5shim 兼容IE6/7/8</p>
</li>
</ul>
</li>
<li><a href="http://cherishsdan.github.io/2016/07/13/manifest/" target="_blank" rel="external">离线存储</a></li>
<li>webSocket如何兼容低浏览器<br>  Adobe Flash Socket、AJAX长轮询、AJAX multipart streaming、持久Iframe、JSONP轮询等</li>
<li><p><a href="">cookies，sessionStorage、localStorage</a><br>  cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。极高的扩展性和可用性<br>  cookie的弊端：<br>  每个特定的域名下最多生成20个cookie（不同浏览器不同）</p>
<pre><code>&lt;=IE6（20）、&gt;=IE7(50)、Firefox（50）、chrome &amp;&amp; Safari（无硬性限制）
</code></pre><p>  IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。<br>  cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。</p>
<p>  IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</p>
<p>  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
<p>  存储大小：</p>
<pre><code>cookie数据大小不能超过4k。
sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
</code></pre><p>  <a href="http://han.guokai.blog.163.com/blog/static/13671827120112694851799/" target="_blank" rel="external">more</a></p>
<p>有期时间：<br>  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>  sessionStorage  数据在当前浏览器窗口关闭后自动删除。在同源的同窗口（或tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁。同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的cookies会发送到服务器端<br>  cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
<p>  Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie</p>
<p>  总的来说，应该根据具体需求选择，cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生</p>
</li>
<li>Web Workers<br>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">MDN</a> <a href="http://www.alloyteam.com/2015/11/deep-in-web-worker/" target="_blank" rel="external">深入理解web Workers</a><br>  通过Web Workers可以创建一个不会影响前台处理的后台线程，并且在这个后台线程中创建多个子线程。在后台线程中不能访问页面或窗口对象的  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>通过 worker = <span class="keyword">new</span> Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>通过worker.postMessage( data ) 方法来向worker发送数据。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>绑定worker.onmessage方法来接收worker发送过来的数据。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>可以使用 worker.terminate() 来终止一个worker的执行。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li>HTTP和HTTPS<br>在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端性能优化——DOM]]></title>
      <url>http://yoursite.com/2016/07/03/eDom/</url>
      <content type="html"><![CDATA[<blockquote>
<p>性能优化系列笔记，提升用户体验</p>
</blockquote>
<p>导致大多数网站和应用程序出现性能滞缓的一个主要因素就是通过javascript低效访问HTML页面元素。因为所有浏览器的javascript引擎独立于其渲染引擎，操作了DOM对象后，会触发一些浏览器行为，比如布局（layout）和绘制（paint），这些行为是非常耗时的。</p>
<h2 id="浏览器工作大致流程"><a href="#浏览器工作大致流程" class="headerlink" title="浏览器工作大致流程"></a>浏览器工作大致流程</h2><p>以Webkit为例：<br><img src="http://ww2.sinaimg.cn/large/005YR2J3jw1eys88jq2soj30hc081t99.jpg" alt="webkit"><br><a id="more"></a></p>
<ul>
<li>解析HTML/SVG/XHTML，并生成一棵DOM tree,解析CSS会产生CSS规则树,解析Javascript脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.</li>
<li>解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree</li>
<li>对Render tree的各个节点计算布局信息，比如box的位置与尺寸</li>
<li>根据Render tree并利用浏览器的UI层进行绘制</li>
</ul>
<p>注意：</p>
<ol>
<li>Rendering Tree 渲染树并不等同于DOM树，因为一些像Head或display:none的东西就没必要放在渲染树中了(但是 visibility 属性值为“hidden”的元素仍会显示)。</li>
<li>CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。然后，计算每个Element的位置，这又叫layout和reflow过程<br><a href="http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Parsing_general" target="_blank" rel="external">more</a></li>
</ol>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p><img src="http://coolshell.cn//wp-content/uploads/2013/05/Render-Process-Skipping-1024x282.jpg" alt="paint"><br>上图流程中有很多连接线，这表示了Javascript动态修改了DOM属性或是CSS属会导致重新Layout，有些改变不会.</p>
<ul>
<li>Repaint:屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变</li>
<li>Reflow:意味着元件的几何尺寸变了，我们需要重新验证并计算Render Tree。Render Tree的一部分或全部发生了变化。在HTML第一次被加载的时候，会有一次layout之外，js脚本的执行和样式的改变同样会导致浏览器执行layout</li>
</ul>
<p>Reflow的成本比Repaint的成本高得多的多。DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。</p>
<p>一般情况下，浏览器的layout是lazy的，也就是说：在js脚本执行时，是不会去更新DOM的，任何对DOM的修改都会被暂存在一个队列中，在当前js的执行上下文完成执行后，会根据这个队列中的修改，进行一次layout。</p>
<p>然而有时希望在js代码中立刻获取最新的DOM节点信息，浏览器就不得不提前执行layout，这是导致DOM性能问题的主因。</p>
<p>reflow:</p>
<ul>
<li>通过js获取需要计算的DOM属性</li>
<li>添加或删除DOM元素</li>
<li>resize浏览器窗口大小</li>
<li>改变字体</li>
<li>css伪类的激活，比如:hover</li>
<li>通过js修改DOM元素样式且该样式涉及到尺寸的改变</li>
</ul>
<p>如果脚本中要获取以下属性，那么积累的reflow将会马上执行，已得到准确的位置信息</p>
<ol>
<li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li>
<li>scrollTop/Left/Width/Height</li>
<li>clientTop/Left/Width/Height</li>
<li>getComputedStyle(), 或 currentStyle</li>
</ol>
<hr>
<p>针对DOM操作的优化，有很多方式和技巧。例如，对于一些DOM的修改操作，可以使用documentFragment、cloneNode等方式，这种方法的原理在于</p>
<blockquote>
<p>对一个不在Render tree上的节点进行一系列操作，再把这个节点添加回Render tree，这样无论多么复杂的DOM操作，最终都只会触发一次layout。</p>
</blockquote>
<p>多使用innerHTML</p>
<blockquote>
<p>当使用innerHTML设置为某个值时，后台会创建一个HTML解释器，然后使用内部的DOM调用来创建DOM结构，而非基于JAVASCRIPT的DOM调用。由于内部方法是编译好的而非解释执行，故执行的更快。对于小的DOM更改，两者效率差不多，但对于大的DOM更改，innerHTML要比标准的DOM方法创建同样的DOM结构快得多</p>
</blockquote>
<p>requestAnimationFrame<br>window.requestAnimationFrame()这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数，以满足开发者操作动画的需求。这个方法接受一个函数为参，该函数会在重绘前调用。<br>使用requestAnimationFrame浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果</p>
<p>参考：<br><a href="https://leozdgao.me/why-dom-slow/" target="_blank" rel="external">https://leozdgao.me/why-dom-slow/</a><br><a href="http://coolshell.cn/articles/9666.html" target="_blank" rel="external">http://coolshell.cn/articles/9666.html</a><br><a href="https://github.com/kahn1990/web_performance_optimization" target="_blank" rel="external">https://github.com/kahn1990/web_performance_optimization</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Interview]]></title>
      <url>http://yoursite.com/2016/06/23/test/</url>
      <content type="html"><![CDATA[<blockquote>
<p>校招准备中，fighting！<br>答案主要是网上一些资料的整理</p>
</blockquote>
<p>输入网址之后发生了什么？<br><a id="more"></a></p>
<ol>
<li>输入网址</li>
<li>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<ul>
<li>如果资源未缓存，发起新请求</li>
<li>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li>
<li>检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：</li>
</ul>
</li>
<li><p>浏览器解析URL获取协议，主机，端口，path,浏览器查找域名对应IP<br> 3.1 DNS查找过程</p>
<ol>
<li>Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）（2-30分钟不等，视浏览器而定）</li>
<li>如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</li>
<li>如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功</li>
<li>如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问www.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候linux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.linux178.com对应的IP地址，该进行一步的动作了。</li>
</ol>
</li>
<li><p>打开一个socket与目标IP地址，端口建立TCP链接<br> 通过 Socket 发送数据<br> 当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443）就可以通过 Socket API 来发送数据了，这时可以选择 TCP 或 UDP 协议，HTTP 常用的是 TCP 协议。它会调用系统库函数 socket ，请求一个 TCP流套接字，对应的参数是 AF_INET 和 SOCK_STREAM </p>
<ul>
<li>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)</li>
<li>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个TCP packet。</li>
<li><p>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame头 部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。</p>
<p>到了现在，TCP 封包已经准备好了，可以使用以太网、WiFi、蜂窝数据网络进行传输。大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理。    </p>
<p>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部TTL域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。</p>
<p><strong>TCP 3次握手</strong><br><img src="http://www.linux178.com/usr/uploads/2014/01/3920594834.png" alt="tcp"></p>
<p>1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复<br>2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。<br>3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</p>
<p><strong>建立TCP连接后发起http请求</strong></p>
</li>
</ul>
<ol>
<li>请求报文 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">起始行：如 GET / HTTP/<span class="number">1.0</span> （请求的方法  请求的URL 请求所使用的协议）</span><br><span class="line">头部信息：User-Agent  Host等成对出现的值</span><br><span class="line">主体</span><br><span class="line"></span><br><span class="line">请求方法有</span><br><span class="line">GET: 完整请求一个资源 （常用）</span><br><span class="line">HEAD: 仅请求响应首部</span><br><span class="line">POST：提交表单  （常用）</span><br><span class="line">PUT: (webdav) 上传 </span><br><span class="line">DELETE：(webdav) 删除 </span><br><span class="line">OPTIONS：返回请求的资源所支持的方法的方法 </span><br><span class="line">TRACE: 追求一个资源请求中间所经过的代理</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<pre><code>例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Accept:*/*</span><br><span class="line">Accept-Encoding:gzip, deflate, sdch, br</span><br><span class="line">Accept-Language:zh-CN,zh;q=0.8</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Cookie:***</span><br><span class="line">Host:mpp.taobao.com</span><br><span class="line">Referer:https://mpp.taobao.com/ajaxconn2.html?appId=1064&amp;token=1cbd5761858c5cfb7ff98da434af6f7766e517db5498216576b9k1s2x4b0f1c35&amp;domain=taobao.org</span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line"></span><br><span class="line">Accept  就是告诉服务器端，我接受那些MIME类型</span><br><span class="line">Accept-Encoding  这个看起来是接受那些压缩方式的文件</span><br><span class="line">Accept-Lanague   告诉服务器能够发送哪些语言 </span><br><span class="line">Connection       告诉服务器支持keep-alive特性</span><br><span class="line">Cookie           每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端</span><br><span class="line">Host             用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多个虚拟主机</span><br><span class="line">         那这里就是用来标识要访问那个虚拟主机。</span><br><span class="line">User-Agent  用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜索引擎的蜘蛛等     </span><br><span class="line"></span><br><span class="line">条件请求首部：</span><br><span class="line">If-Modified-Since 是浏览器向服务器端询问某个资源文件如果自从什么时间修改过，那么重新发给我，这样就保证服务器端资源</span><br><span class="line">     文件更新时，浏览器再次去请求，而不是使用缓存中的文件</span><br><span class="line">安全请求首部：</span><br><span class="line">Authorization: 客户端提供给服务器的认证信息；</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>到达服务器</p>
<ul>
<li><p>负载均衡</p>
<p>请求在进入到真正的应用服务器前，可能还会先经过负责负载均衡的机器，它的作用是将请求合理地分配到多个服务器上，同时具备具备防攻击等功能。<br>负载均衡具体实现有很多种，有直接基于硬件的 F5，有操作系统传输层(TCP)上的 LVS，也有在应用层(HTTP)实现的反向代理（也叫七层代理），接下来将介绍 LVS 及反向代理。</p>
<p>负载均衡的策略也有很多，如果后面的多个服务器性能均衡，最简单的方法就是挨个循环一遍(Round-Robin)</p>
</li>
<li><p>LVS<br>LVS 的作用是从对外看来只有一个 IP，而实际上这个 IP 后面对应是多台机器，因此也被成为 Virtual IP。</p>
</li>
<li>反向代理<br>向代理是工作在 HTTP 上的，具体实现可以基于 HAProxy 或 Nginx，因为反向代理能理解 HTTP 协议，所以能做非常多的事情，比如：进行很多统一处理，比如防攻击策略、放抓取、SSL、gzip、自动性能优化等。应用层的分流策略都能在这里做，比如对 /xx 路径的请求分到 a 服务器，对 路径的请求分到 b 服务器，或者按照 cookie 进行小流量测试等<br>缓存，并在后端服务挂掉的时候显示友好的 404 页面<br>监控后端服务是否异常</li>
</ul>
</li>
<li><p>重定向<br>当我们输入不完整的网址<br>时，或者网站迁移做了重定向设置时，服务器会进行一次重定向响应。 重定向之后会发布一个新的获取请求</p>
</li>
<li><p>服务器处理请求</p>
</li>
</ol>
<blockquote>
<p>web服务器软件（如IIS或者Apache）接收到HTTP请求<br>确定执行那个请求处理程序<br>请求处理器阅读请求头的参数和cookies信息<br>更新服务器上的信息：例如更新数据库信息、服务端cookies<br>生成HTML，压缩（gzip或其他），响应请求发送给用户</p>
</blockquote>
<ul>
<li>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码</li>
<li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</li>
<li>服务器将响应报文通过TCP连接发送回浏览器</li>
</ul>
<ol>
<li>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下<ul>
<li>主动方发送Fin=1， Ack=Z， Seq= X报文</li>
<li>被动方发送ACK=X+1， Seq=Z报文</li>
<li>被动方发送Fin=1， ACK=X， Seq=Y报文</li>
<li>主动方发送ACK=Y， Seq=X报文</li>
</ul>
</li>
<li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</li>
<li>如果资源可缓存，进行缓存</li>
<li>对响应进行解码（例如gzip压缩）</li>
<li>根据资源类型决定如何处理（假设资源为HTML文档）<br>服务器发回一个HTML响应</li>
</ol>
<p>响应包括响应头（响应参数与信息）、响应包（主体文件）<br>响应包采用特定方法压缩，整个响应以blob类型传输，响应头指示响应包以何种方式压缩<br>这个响应头与重定向的响应头不太一样，这个响应头还包含着缓存选项，cookies设置和隐私信息等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">connection:keep-alive</span><br><span class="line">Content-Type:text/html;charset=utf-8</span><br><span class="line">date:Sat, 23 Jul 2016 04:15:48 GMT</span><br><span class="line">server:Cowboy</span><br><span class="line">transfer-encoding:chunked</span><br><span class="line"></span><br><span class="line">Connection            使用keep-alive特性</span><br><span class="line">Content-type          MIME类型为html类型，字符集是 UTF-8</span><br><span class="line">Date                  响应的日期</span><br><span class="line">Server                使用的WEB服务器</span><br><span class="line">Transfer-Encoding:chunked   分块传输编码 是http中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（通常是网页浏览器）的数据可以分成多个部分，分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供</span><br><span class="line"></span><br><span class="line">获取静态资源时</span><br><span class="line">Content-Encoding      资源压缩</span><br><span class="line">Cache-Control:max-age=3600</span><br><span class="line">Expires:Sat, 23 Jul 2016 06:11:08 GMT</span><br><span class="line">Last-Modified:Thu, 24 Sep 2015 12:50:17 GMT</span><br></pre></td></tr></table></figure>
<p>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序</p>
<ul>
<li>构建DOM树<ul>
<li>Tokenizing：根据HTML规范将字符流解析为标记</li>
<li>Lexing：词法分析将标记转换为对象并定义属性和规则</li>
<li>DOM construction：根据HTML标记关系将对象组成DOM树<br>加载过程中遇到外部css文件，浏览器发出一个请求，来获取css文件。<br>遇到图片资源，浏览器也会发出一个请求，来获取图片资源。这是异步请求，并不会影响html文档进行加载，但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。虽然css文件的加载不影响js文件的加载，但是却影响js文件的执行，即使js文件内只有一行代码，也会造成阻塞。<a href="http://www.jianshu.com/p/e141d1543143" target="_blank" rel="external">more</a></li>
</ul>
</li>
<li>构建CSSOM树<ul>
<li>Tokenizing：字符流转换为标记流</li>
<li>Node：根据标记创建节点</li>
<li>CSSOM：节点创建CSSOM树</li>
</ul>
</li>
<li>根据DOM树和CSSOM树构建渲染树:<ul>
<li>从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none</li>
<li>对每一个可见节点，找到恰当的CSSOM规则并应用</li>
<li>发布可视节点的内容和计算样式</li>
</ul>
</li>
<li>js解析如下：<ul>
<li>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading</li>
<li>HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</li>
<li>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素</li>
<li>当文档完成解析，document.readState变成interactive</li>
<li>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()</li>
<li>浏览器在Document对象上触发DOMContentLoaded事件</li>
<li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件<br>12.显示页面（HTML解析过程中会逐步显示页面）</li>
</ul>
</li>
</ul>
<p><a href="http://cherishsdan.github.io/2016/07/03/eDom/" target="_blank" rel="external">more</a><br><strong>浏览器高层架构</strong></p>
<p>组成浏览器的组件有:</p>
<ul>
<li>用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分</li>
<li>浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作</li>
<li>渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上</li>
<li>网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现</li>
<li>UI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现</li>
<li>Javascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码</li>
<li>数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</li>
</ul>
<p><strong>浏览器获取其他文件</strong><br>浏览器解析HTML遇到需要下载的文件时，便再次向服务器（CDN）发送获取文件的请求。</p>
<ul>
<li>动态页面无法缓存，静态文件允许浏览器进行缓存。 </li>
<li>静态文件本地有缓存时直接从本地读取 </li>
<li>请求响应头内包含着静态文件保存的期限，浏览器知道下载的静态文件要静默保留多久。 </li>
<li>响应头还会有静态文件的ETag（相当于版本号），当浏览器发现请求的静态文件的响应头的ETag与现有的缓存文件不符时，便会再次向服务器获取静态文件。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 异步编程]]></title>
      <url>http://yoursite.com/2016/06/20/promise/</url>
      <content type="html"><![CDATA[<p>所谓的异步指的是函数的调用并不直接返回执行的结果，而往往是通过回调函数异步的执行。异步的主要目的是处理非阻塞，在和HTML交互的过程中，会需要一些IO操作（典型的就是Ajax请求，脚本文件加载），如果这些操作是同步的，就会阻塞其它操作，用户的体验就是页面失去了响应。avascript通过事件驱动机制，在单线程模型下，以异步回调函数的形式来实现非阻塞的IO操作。</p>
<h2 id="常见的异步模型"><a href="#常见的异步模型" class="headerlink" title="常见的异步模型"></a>常见的异步模型</h2><ul>
<li>高阶函数</li>
<li><p>事件监听</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f.on(<span class="string">"evt"</span>, g);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    f.trigger(<span class="string">"evt"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布/订阅</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E.subscribe(<span class="string">"evt"</span>, g);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    　　<span class="comment">// f的任务代码</span></span><br><span class="line">    　　E.publish(<span class="string">"evt"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise</p>
</li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promises规范就是为了解决这个问题而提出的，目标是使用正常的程序流程（同步），来处理异步操作。</p>
<p>Promise把类似的异步处理对象和处理规则进行规范化， 并按照采用统一的接口来编写，采取规定方法之外的写法都会出错。promise的功能是可以将复杂的异步处理轻松地进行模式化。<br>简单来说，它起到代理作用（proxy），充当异步操作与回调函数之间的中介。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用。<br>ECMAScript 6将其写入语言标准，因此目前JavaScript语言原生支持Promise对象。<br>更多Promise操作-<a href="">Promise</a></p>
<h2 id="异步操作的流程控制"><a href="#异步操作的流程控制" class="headerlink" title="异步操作的流程控制"></a>异步操作的流程控制</h2><p>1、串行执行</p>
<p>可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">series</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(item) &#123;</span><br><span class="line">    <span class="keyword">async</span>( item, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      results.push(result);</span><br><span class="line">      <span class="keyword">return</span> series(items.shift());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> final(results);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">series(items.shift());</span><br></pre></td></tr></table></figure>
<p>函数series就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行final函数。items数组保存每一个异步任务的参数，results数组保存每一个异步任务的运行结果</p>
<p>2、并行执行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"></span><br><span class="line">items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">async</span>(item, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    results.push(result);</span><br><span class="line">    <span class="keyword">if</span>(results.length == items.length) &#123;</span><br><span class="line">      final(results);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，forEach方法会同时发起6个异步任务，等到它们全部完成以后，才会执行final函数。</p>
<p>并行执行的好处是效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式</p>
<p>3、并行与串行的结合<br>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务。这样就避免了过分占用系统资源。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"><span class="keyword">var</span> running = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> limit = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">launcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(running &lt; limit &amp;&amp; items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = items.shift();</span><br><span class="line">    <span class="keyword">async</span>(item, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      results.push(result);</span><br><span class="line">      running--;</span><br><span class="line">      <span class="keyword">if</span>(items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        launcher();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(running == <span class="number">0</span>) &#123;</span><br><span class="line">        final();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    running++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launcher();</span><br></pre></td></tr></table></figure>
<h2 id="JavaScript-多线程"><a href="#JavaScript-多线程" class="headerlink" title="JavaScript 多线程"></a>JavaScript 多线程</h2><p>JavaScript 中的 Worker 对象可以创建一个独立线程来处理数据，很自然的处理了阻塞问题。我们可以把繁重的计算任务交给 Worker,等他处理完了再把数据 Post 过来。</p>
<p>Worker 是一个有用的工具,可以创建 ajax 对象和 WebSocket 对象，也就是说他可以直接向服务器请求数据。不过他不能访问 DOM 的信息，更不能直接处理 DOM。</p>
<p>更多的worker-<a href="">worker</a></p>
<h2 id="Generator-对象解决异步"><a href="#Generator-对象解决异步" class="headerlink" title="Generator 对象解决异步"></a>Generator 对象解决异步</h2><p>参考：<a href="https://segmentfault.com/a/1190000002545312" target="_blank" rel="external">https://segmentfault.com/a/1190000002545312</a><br>      <a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[立即执行函数表达式]]></title>
      <url>http://yoursite.com/2016/06/12/iife/</url>
      <content type="html"><![CDATA[<p>function foo(){ /<em> code </em>/ }();//SyntaxError: Unexpected token<br>function(){ /<em> code </em>/}(); //SyntaxError: Unexpected token</p>
<p>圆括号为了调用函数出现在函数后面时，无论在全局环境或者局部环境里遇到了这样的function关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式.因为 JavaScript 文法明确规定表达式语句不得以 function 或者 { 开头.</p>
<p>所以便出现了下面几种形式：<br>(function(){/<em> code </em>/}())<br>(function(){/<em> code </em>/})()<br>!function(){/<em> code </em>/}();<br>~function(){/<em> code </em>/}();<br>-function(){/<em> code </em>/}();<br>+function(){/<em> code </em>/}();<br>…</p>
<h2 id="最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能包含声明。因为这点，当圆括号为了包裹函数碰上了-function关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。"><a href="#最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能包含声明。因为这点，当圆括号为了包裹函数碰上了-function关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。" class="headerlink" title="最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能包含声明。因为这点，当圆括号为了包裹函数碰上了 function关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。"></a>最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能包含声明。因为这点，当圆括号为了包裹函数碰上了 function关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。</h2><p>函数表达式 &amp;&amp; 函数声明</p>
<p>函数表达式中的函数可以为匿名函数，也可以有函数名，但是不能直接使用，只能通过表达式左边的变量 a 来调用。<br><code>var a = function(){
alert(&#39;Function expression&#39;);
}
var b = new a();</code></p>
<p>函数声明时必须有函数名<br><code>function a(){
alert(&#39;Function declaration&#39;);
}
a();</code><br>`</p>
<p><script><br>!function() {<br>alert(“hello, world.”);<br>} ();<br></script><br>`<br>匿名函数通过一元操作符变成了函数表达式，因而可以通过（）来调用。<br>因此，执行匿名函数可以通过+，-，！，（） 这样的形式来转化为函数表达式，就可以通过（）来运行了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Module]]></title>
      <url>http://yoursite.com/2016/06/10/moudle/</url>
      <content type="html"><![CDATA[<p>关于模块化：</p>
<ul>
<li>可重用</li>
<li>封装了变量和function，和全局的namaspace不接触，松耦合</li>
<li>只暴露可用public的方法，其它私有方法全部隐藏<a id="more"></a></li>
</ul>
<ol>
<li>基本的模块化</li>
</ol>
<h2 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = &#123;</span><br><span class="line">    m1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    m2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>减少 Global 上的变量数目,起到了一点点的命名空间作用<br>同样缺点明显: 会暴露所有模块成员，内部状态可以被外部改写</p>
<h2 id="匿名闭包-：IIFE-模式"><a href="#匿名闭包-：IIFE-模式" class="headerlink" title="匿名闭包 ：IIFE 模式"></a>匿名闭包 ：IIFE 模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _private = <span class="string">"safe"</span>;</span><br><span class="line">    <span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        m1: m1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">Module.m1();</span><br><span class="line">Module._private; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>可以很好的保护私有变量，通过return来设置公开的方法<br>动态添加方法的时候比较麻烦，且无法修改内部私有变量.</p>
<h2 id="引用全局变量"><a href="#引用全局变量" class="headerlink" title="引用全局变量"></a>引用全局变量</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _$body = $(<span class="string">"body"</span>);     <span class="comment">// can use jQuery </span></span><br><span class="line">    <span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="comment">/* code */</span>  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        m1: m1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery)</span><br><span class="line"></span><br><span class="line">Module.m1();</span><br></pre></td></tr></table></figure>
<p>全局变量当成一个参数传入到匿名函数然后使用.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = &#123;&#125;, </span><br><span class="line">    _private = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateM1</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">         <span class="comment">/* code */</span>  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m.attr = _private;</span><br><span class="line">    m.method = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        privateM1(data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125; ());</span><br></pre></td></tr></table></figure>
<p>全局变量Module带有2个可访问的属性Module.method和Module.，除此之外，其它代码都在匿名函数的闭包里保持着私有状态。</p>
<h2 id="module-扩展"><a href="#module-扩展" class="headerlink" title="module 扩展"></a>module 扩展</h2><p>将一个功能分离成多个文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    m.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* code */</span>  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125; (Module));</span><br></pre></td></tr></table></figure>
<h3 id="松耦合扩展"><a href="#松耦合扩展" class="headerlink" title="松耦合扩展"></a>松耦合扩展</h3><p>解决顺序问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    m.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* code */</span>  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125; (Module || &#123;&#125;));</span><br></pre></td></tr></table></figure>
<p>首个被引入的文件会创建Module命名空间（就是个JavaScript对象），而且所有使用这种结构的后续文件都只是重用此现有实例。</p>
<h3 id="紧耦合扩展"><a href="#紧耦合扩展" class="headerlink" title="紧耦合扩展"></a>紧耦合扩展</h3><p>紧耦合扩展限制了加载顺序，但是提供了我们重载的机会</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldMethod = m.AddMethod;</span><br><span class="line"></span><br><span class="line">    m.AddMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* code </span><br><span class="line">        可通过oldMethod调用旧的方法</span><br><span class="line">        */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125; (Module));</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>全局作用域下容易造成变量冲突</li>
<li>文件只能按照 script 的书写顺序进行加载</li>
<li>开发人员必须主观解决模块和代码库的依赖关系</li>
<li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li>
</ul>
<hr>
<p>模块规范</p>
<ul>
<li>COMMONJS<br>  CommonJS中，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的，除非定义为global对象的属性。<br>  通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口<br>  CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。<br>  <a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="external">more</a></li>
<li><p>AMD<br>  AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。RequireJS遵守AMD规范<br>  模块通过 define 函数定义在闭包中，格式如下<br>  <code>define(id?, dependencies?, factory);</code><br>  id 是模块的名字，它是可选的参数。<br>  dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [“require”, “exports”, “module”]<br>  factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。<br>  <a href="http://javascript.ruanyifeng.com/tool/requirejs.html" target="_blank" rel="external">more</a></p>
</li>
<li><p>CMD<br>  AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。</p>
<ul>
<li>依赖就近，延迟执行</li>
<li>可以很容易在 Node.js 中运行</li>
</ul>
</li>
<li>AMD VS CMD<ul>
<li>CMD推崇依赖就近，可以把依赖写进你的代码中的任意一行，代码在运行时，首先是不知道依赖的，需要遍历所有的require关键字，找出后面的依赖。具体做法是将function toString后，用正则匹配出require关键字后面的依赖。显然，这是一种牺牲性能来换取更多开发便利的方法。</li>
<li>而AMD是依赖前置的，换句话说，在解析和执行当前模块之前，模块作者必须指明当前模块所依赖的模块，无需遍历整个函数体找到它的依赖，因此性能有所提升，缺点就是开发者必须显式得指明依赖——这会使得开发工作量变大<br>大势所趋：</li>
</ul>
</li>
<li>Browserify - CommonJS In Browser<br>  Browserify是一个node.js模块，主要用于改写现有的CommonJS模块，使得浏览器端也可以使用这些模块</li>
<li>Webpack - Module Bundler<br>  Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</li>
</ul>
<p>requirejs是一种在线”编译” 模块的方案，相当于在页面上加载一个AMD 解释器，以便于览器能够识别 define、exports、module，而这些东西就是用于模块化的关键。<br>而browserify / webpack，则是一个预编译模块的方案。它是预编译的，不需要在浏览器中加载解释器。</p>
<ul>
<li><p>ES6 Module<br>  ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西</p>
<p>  模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。<br>  <a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="external">more</a></p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node.js(四)-内存控制]]></title>
      <url>http://yoursite.com/2016/06/08/node4/</url>
      <content type="html"><![CDATA[<blockquote>
<p>再次阅读《深入浅出Node.js》的笔记系列，内容主要摘自书中</p>
</blockquote>
<p>在node中使用内存时只能使用部分内存（64位为1.4GB，32位为0.7GB），造成这个问题的主要原因是Node基于V8构建，所以在Node中使用的javascript对象基本上是通过V8自己的方式来进行分配和管理的（Buffer对象不经过V8的内存分配限制）。<br>在V8中，所有的javascript对象都是通过堆来进行分配的。在Node启动时可以传递<br>–max-old-space-size / –max-new-space-size调整内存限制</p>
<h2 id="v8的内存管理模式"><a href="#v8的内存管理模式" class="headerlink" title="v8的内存管理模式"></a>v8的内存管理模式</h2><p>一个运行的程序通常是通过在内存中分配一部分空间来表示的。这部分空间被称为驻留集（Resident Set）。 V8的内存管理模式有点类似于Java虚拟机（JVM），它会将内存进行分段：</p>
<ul>
<li>代码 Code：实际被执行的代码</li>
<li>栈 Stack：包括所有的携带指针引用堆上对象的值类型（原始类型，例如整型和布尔），以及定义程序控制流的指针。</li>
<li>堆 Heap：用于保存引用类型（包括对象、字符串和闭包）的内存段</li>
</ul>
<h2 id="v8的垃圾回收机制"><a href="#v8的垃圾回收机制" class="headerlink" title="v8的垃圾回收机制"></a>v8的垃圾回收机制</h2><p>垃圾回收器解决基本问题就是，识别需要回收的内存。一旦辨别完毕，这些内存区域即可在未来的分配中重用，或者是返还给操作系统。一个对象当它不是处于活跃状态的时候它就死了。一个对象处于活跃状态，当且仅当它被一个根对象或另一个活跃对象指向。根对象被定义为处于活跃状态，是浏览器或V8所引用的对象。比如说全局对象属于根对象，因为它们始终可被访问；浏览器对象，如DOM元素，也属于根对象，尽管在某些场合下它们只是弱引用。</p>
<h3 id="堆的构成"><a href="#堆的构成" class="headerlink" title="堆的构成"></a>堆的构成</h3><p>在 node-v4.x 之后，堆主要由以下及部分构成：</p>
<ul>
<li>新生区：大多数对象开始时被分配在这里。新生区是一个很小的区域，垃圾回收在这个区域非常频繁，与其他区域相独立。</li>
<li>老生区：保存原始数据对象，大多数从新生代晋升的对象会被移动到这里</li>
<li>大对象区：这里存放体积超过1MB大小的对象。每个对象有自己的内存。垃圾回收器从不移动大对象</li>
<li>Map区</li>
<li>Code区：代码对象，也就是包含JIT之后指令的对象，会被分配到这里</li>
</ul>
<h3 id="识别指针和数据"><a href="#识别指针和数据" class="headerlink" title="识别指针和数据"></a>识别指针和数据</h3><p>垃圾回收器面临的第一个问题是，如何才能在堆中区分指针和数据，因为指针指向着活跃的对象。大多数垃圾回收算法会将对象在内存中挪动（以便减少内存碎片，使内存紧凑），因此即使不区分指针和数据，我们也常常需要对指针进行改写。<br>V8采用了标记指针法：这种方法需要在每个指针的末位预留一位来标记这个字代表的是指针或数据。</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>如果新生区中某个对象，只有一个指向它的指针，而这个指针恰好是在老生区的对象当中，我们如何才能知道新生区中那个对象是活跃的呢？ 为了解决这个问题，实际上在写缓冲区中有一个列表 store-buffer{.cc,.h,-inl.h}，列表中记录了所有老生区对象指向新生区的情况。新对象诞生的时候，并不会有指向它的指针，而当有老生区中的对象出现指向新生区对象的指针时，我们便记录下来这样的跨区指向。由于这种记录行为总是发生在写操作时，它被称为写屏障.</p>
<h3 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h3><p>V8采用了一种分代回收的策略，将内存分为两个生代：新生代和老生代。新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件时，会被移动到老生代（晋升）</p>
<p>1、V8的分代内存<br>默认情况下，64位环境下的V8引擎的新生代内存大小32MB、老生代内存大小为1400MB，而32位则减半，分别为16MB和700MB。V8内存的最大保留空间分别为1464MB（64位）和732MB（32位）。具体的计算公式是4*reserved_semispace<em>space</em> + max_old_generation<em>size</em>，新生代由两块reserved_semispace<em>space</em>组成，每块16MB（64位）或8MB（32位）</p>
<p>2、新生代<br>大多数的对象被分配在这里，这个区域很小但是垃圾回收特别频繁。新生代使用半空间（Semi-space）分配策略，其中新对象最初分配在新生代的活跃半空间内。</p>
<ul>
<li>Scavenge算法<br>新生代使用Scavenge算法进行回收。在Scavenge算法的实现中，主要采用了Cheney算法</li>
</ul>
<p>Cheney算法算法是一种采用复制的方式实现的垃圾回收算法。它将内存一分为二，每一部分空间称为semispace。在这两个semispace中，一个处于使用状态，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间，当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收算法时，会检查From空间中的存活对象，这些存活对象将会被复制到To空间中（复制完成后会进行紧缩），而非活跃对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace之间进行复制。<br>Scavenge算法（牺牲空间换取时间）的缺点是只能使用内存的一半，但它只复活存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它的时间效率比较高</p>
<p>执行过程：<br>a、将From空间中所有能从根对象到达的对象复制到To区（scanPtr和allocationPtr指针，分别指向即将扫描的活跃对象和即将为新对象分配内存的地方）<br>b、开始循环，查找当前scanPtr所指向的对象的内部指针指向，指向From区，就把这个所指向的对象从From区复制到To区<br>c、复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址，并移动allocationPtr<br>d、下一轮循环，直到scanPtr和allocationPtr相遇，开始清理垃圾</p>
<p>3、对象晋升<br>具体移动的标准有两种：</p>
<ul>
<li>对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中</li>
<li>对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代</li>
</ul>
<p>4、老生代<br>V8在老生代中的垃圾回收策略采用Mark-Sweep和Mark-Compact相结合<br>Mark-Sweep：标记清除分为标记和清除两个阶段。在标记阶段需要遍历堆中的所有对象，并标记那些活着的对象，然后进入清除阶段。在清除阶段总，只清除没有被标记的对象。由于标记清除只清除死亡对象，而死亡对象在老生代中占用的比例很小，所以效率较高<br>问题：内存碎片</p>
<p>Mark-Compact（标记整理）：标记整理正是为了解决标记清除所带来的内存碎片的问题。标记整理在标记清除的基础进行修改。在整理的过程中，将活着的对象向内存区的一段移动，移动完成后直接清理掉边界外的内存。紧缩过程涉及对象的移动，所以效率并不是太好，但是能保证不会生成内存碎片</p>
<p>V8的老生代使用标记清除和标记整理结合的方式，主要采用标记清除算法，如果空间不足以分配从新生代晋升过来的对象时，才使用标记整理</p>
<p>5、优化<br>Incremental Marking（增量标记）<br>拆分成很多部分，每做完一部分就停下来，让JS的应用逻辑执行一会，这样垃圾回收与应用逻辑交替完成。经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原来的1/6左右</p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="http://o6qp6st9j.bkt.clouddn.com/images/node/cache.png" alt="cache"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node.js(三)-异步I/O]]></title>
      <url>http://yoursite.com/2016/06/04/node3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>再次阅读《深入浅出Node.js》的笔记系列，内容主要摘自书中</p>
</blockquote>
<p>Node 利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O,让单线程远离阻塞，以更好的使用CPU。</p>
<p>阻塞I/O的一个特点是调用完成后一定要等到系统内核层面完成所有操作后。调用才结束。阻塞I/O造成CPU等待，浪费等待时间，CPU处理能力得不到充分利用，为了提高性能，内核提供了非阻塞I/O。非阻塞I/O调用之后会立即返回.返回之后，cpu的时间片可以用来处理其他事务。</p>
<h2 id="基于libuv的架构"><a href="#基于libuv的架构" class="headerlink" title="基于libuv的架构"></a>基于libuv的架构</h2><p>node提供了libuv作为抽象层，使得所有平台兼容性的判断都由这一层完成，并保证上层的Node与下层的自定义线程池及IOCP之间各自独立，Node在编译期间会判断平台条件。在Node v0.9.3，*nix自行实现了线程池来完成。<br><img src="https://yjhjstz.gitbooks.io/deep-into-node/content/chapter1/FuX1qcGJgwYtX9zNbBAOSaQeD8Qz.png" alt="libuv"></p>
<p>从图中可以看出，对于Network I/O和以File I/O为代表的另一类请求，异步处理的底层支撑机制是完全不一样的。</p>
<p>对于Network I/O相关的请求， 根据OS平台不同，分别使用Linux上的epoll，OSX和BSD类OS上的kqueue，SunOS上的event ports以及Windows上的IOCP机制。</p>
<p>而对于File I/O为代表的请求，则使用thread pool。利用thread pool的方式实现异步请求处理，在各类OS上都能获得很好的支持。</p>
<p>要强调的是，我们时常提到的Node是单线程的，这里的单线程指的是javascript执行在单线程中，在Node中，无论是*nix还是windows平台，内部完成I/O的另有线程池。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node.js(二)-模块机制]]></title>
      <url>http://yoursite.com/2016/06/02/node2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>再次阅读《深入浅出Node.js》的笔记系列，内容主要摘自书中</p>
</blockquote>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS规范加载模块是同步的。根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。<br>CommonJS规定，每个文件的对外接口是module.exports对象。这个对象的所有属性和方法，都可以被其他文件导入。</p>
<p>CommonJS模块的特点如下：</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序</li>
</ul>
<a id="more"></a>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>Node内部提供一个Module构建函数。所有模块都是Module的实例。每个模块内部，都有一个module对象，代表当前模块，它的属性包括（module.id,module.filename,module.loaded,module.parent,module.children,module.exports）</p>
<ul>
<li>module.exports &amp;&amp; exports<br>  module.exports属性表示当前模块对外输出的接口,为了方便，Node为每个模块提供一个exports变量，指向module.exports。等同于<br>  <code>var exports = module.exports;</code><br>  exports对象是通过形参方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值。</li>
</ul>
<h2 id="思维脑图"><a href="#思维脑图" class="headerlink" title="思维脑图"></a>思维脑图</h2><p><img src="http://o6qp6st9j.bkt.clouddn.com/images/node/module.png" alt="node"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node.js(一)-简介]]></title>
      <url>http://yoursite.com/2016/06/01/node1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>再次阅读《深入浅出Node.js》的笔记系列，内容主要摘自书中</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Node.js主要分为四大部分，Node Standard Library，Node Bindings，V8，Libuv，架构图如下：<br><img src="https://yjhjstz.gitbooks.io/deep-into-node/content/chapter1/a9e67142615f49863438cc0086b594e48984d1c9.jpeg" alt="node1"></p>
<ul>
<li>Node Standard Library 是我们每天都在用的标准库，如Http, Buffer 模块。</li>
<li>Node Bindings 是沟通JS 和 C++的桥梁，封装V8和Libuv的细节，向上层提供基础API服务</li>
<li>第三层是支撑 Node.js 运行的关键，由 C/C++ 实现<ul>
<li>V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机。</li>
<li>Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力</li>
<li>C-ares：提供了异步处理 DNS 相关的能力。</li>
<li>http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力</li>
</ul>
</li>
</ul>
<h2 id="思维脑图"><a href="#思维脑图" class="headerlink" title="思维脑图"></a>思维脑图</h2><p><img src="http://o6qp6st9j.bkt.clouddn.com/images/node/Node%E7%AE%80%E4%BB%8B.png" alt="node"></p>
<p>部分摘自：<a href="https://yjhjstz.gitbooks.io/deep-into-node/content/chapter1/chapter1-0.html" target="_blank" rel="external">https://yjhjstz.gitbooks.io/deep-into-node/content/chapter1/chapter1-0.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[跨域]]></title>
      <url>http://yoursite.com/2016/05/28/Cors/</url>
      <content type="html"><![CDATA[<blockquote>
<p>对跨域的一些总结，方便日后查阅</p>
</blockquote>
<p>跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但返回结果被浏览器拦截了，有些浏览器不允许从HTTPS协议的域 跨域访问 HTTP协议，比如Chrome和Firefox，这些浏览器在请求还未发出的时候就会拦截请求</p>
<ul>
<li><p>同源策略<br>  如果两个页面拥有相同的协议（protocol），端口，和域名，那么这两个页面就属于同一个源（origin），JavaScript 允许这种同源页面的数据互相通信。<br>  一般web页面的端口号默认都是80</p>
<p>  例如：<a href="http://xxx.com/a.html" target="_blank" rel="external">http://xxx.com/a.html</a> 协议是http、端口：80、域名：xxx.com</p>
<p>  若非同源，则以下行为会受到限制：</p>
<ol>
<li>Cookie、LocalStorage 和 IndexedDB 无法读取</li>
<li>DOM 无法获得</li>
<li>AJAX 请求不能发送</li>
</ol>
</li>
</ul>
<p>跨域方案</p>
<ul>
<li><p>经典的JSONP<br>  <strong>回调函数和数据</strong>(script标签可以加载并执行其他域JS文件)</p>
<p>  原理：站点A动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数(站点B把要提供的数据作为参数传给一个站点A定义的全局函数)，并且会把我们需要的json数据作为参数传入。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    &lt;script src=<span class="string">"http://xxx.com/data.php?callback=dosomething"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dosomething</span>(<span class="params">jsondata</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(jsondata);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>  js文件载入成功后，会执行我们在url参数中指定的函数（dosomething），并且会把我们需要的json数据（jsondata）作为参数传入。所以再次强调jsonp是需要服务器端的页面进行相应的配合的。</p>
  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$callback = $_GET[<span class="string">'callback'</span>];</span><br><span class="line">$data = &#123;<span class="string">'name'</span>:<span class="string">'XXX'</span>,sex:<span class="string">'X'</span>,age:<span class="string">'X'</span>&#125;;</span><br><span class="line"><span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>  缺点：1、 仅适应于HTTP的Get请求,不支持POST等其它类型的HTTP请求，不能提交大量数据；</p>
<pre><code>2、 缺乏错误处理机制
3、 不能解决不同域的两个页面之间如何进行JavaScript调用的问题
</code></pre><p>  优点：1、 兼容性更好，在老版本的浏览器中可以运行</p>
<pre><code>2、 请求完毕后可以通过调用callback的方式回传结果，方便调用
</code></pre></li>
<li><p>子域名代理<br>  在不同的子域 + iframe交互的时候，获取到另外一个 iframe 的 window对象是没有问题的，但是获取到的这个window的方法和属性大多数都是不能使用的</p>
<p>  解决方法：document.domain</p>
<p>  例如：A页面：<a href="http://xxx.com/a.html,在这个页面里面有一个iframe，它的src是http://y.xxx.com/b.html" target="_blank" rel="external">http://xxx.com/a.html,在这个页面里面有一个iframe，它的src是http://y.xxx.com/b.html</a></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.html</span></span><br><span class="line">&lt;iframe id = <span class="string">"iframe"</span> src=<span class="string">"http://y.xxx.com/b.html"</span> onload = <span class="string">"test()"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'xxx.com'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>).contentWindow);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b.html</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'xxx.com'</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>  document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</p>
</li>
<li><p>CORS<br>  跨域资源共享。定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通.原理就是使用自定义的 HTTP 头部，让服务器能声明 哪些来源可以通过浏览器访问该服务器上的资源，从而决定请求或响应是应该成功还是失败,主要是通过设置响应头的 Access-Control-Allow-Origin 来达到目的的<br>  <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">more</a></p>
</li>
</ul>
<ul>
<li>window.name</li>
</ul>
<p>在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。</p>
<ul>
<li>window.postMessage()<br>使用它来向其它的window对象发送消息,无论这个window对象是属于同源或不同源</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue杂记]]></title>
      <url>http://yoursite.com/2016/05/26/vue/</url>
      <content type="html"><![CDATA[<blockquote>
<p>VueJS学习过程中一些想法，杂记</p>
</blockquote>
<ol>
<li>el<br> 一般传入一个id，简单来说，就是表示在这个id之后的内容，由vue接管了。<br> <code>input(type=&quot;text&quot;, placeholder=&quot;请输入关键字&quot;, v-model=&quot;keywords&quot;, v-el:keywords, autocapitalize=&quot;off&quot;, debounce=&quot;500&quot;)</code><br> v-el在这里，表示对这个标签的一个引用，简单来说就是一个别名<br>2.缩写<br> v-bind:href=”url”——:href=”url”<br> v-on:click=”doSomething”——@click=”doSomething”</li>
<li><code>:class=&quot;{&#39;nav-slide&#39; : isSlide}</code><br> 意思是isSlide为True时，就应用nav-slide类</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[react杂记]]></title>
      <url>http://yoursite.com/2016/05/21/react/</url>
      <content type="html"><![CDATA[<p>react学习过程中的一些记录~</p>
<blockquote>
<p>现在我们已经清楚，React的美妙和本质与浏览器或DOM无关，<br>我们认为React的真正基础是关于组件和元素的质朴想法：用声明式的方式来描述任何你想渲染的东西。</p>
</blockquote>
<a id="more"></a>
<h2 id="virtual-Dom"><a href="#virtual-Dom" class="headerlink" title="virtual Dom"></a>virtual Dom</h2><p><img src="http://o6qp6st9j.bkt.clouddn.com/reactVirtualDom.PNG" alt="virtual Dom"></p>
<p>react本身就是帮我们管理view的，它提出了一个virtualdom的概念，在虚拟dom中，react<br>会去检查它与浏览器dom有什么不同，然后去更新dom树中发生了改变的子节点。</p>
<p>我们编写了react中的render()方法，然后去设置我们需要的一些状态，定义好这个组件后，当组件渲染完成后，组件发生变化，我们只需要修改state，react会替我们更新这些dom到浏览器中，虚拟dom也可以在服务器端渲染。</p>
<p>React的组件使用特定的声明式样式书写，不像jQuery或其它传统JS库，你不与DOM直接交互。当背后的数据改变时，React接管所有的UI更新。</p>
<p>作为开发人员，我们只需要开发组件，然后去管理组件本身的状态。</p>
<blockquote>
<p>在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造<br>是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React当前<br>整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分<br>进行实际的浏览器DOM更新。而且React能够批处理虚拟DOM的刷新，在一个事件循环<br>EventLoop）内的两次数据变化会被合并，例如你连续的先将节点内容从A变成B，然后又<br>B变成A，React会认为UI不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复<br>杂的。尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是<br>极高的，而对实际DOM进行操作的仅仅是Diff部分，因而能达到提高性能的目的。这样，<br>在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体<br>的DOM元素，而只需要关心在任意一个数据状态下，整个界面是如何Render的。</p>
</blockquote>
<h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><blockquote>
<p>所谓组件，即封装起来的具有独立功能的UI部件。React推荐以组件的方式去重新思考UI构成，<br>  将UI上每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体UI的构建。</p>
</blockquote>
<p>对于MVC开发模式来说，开发者将三者定义成不同的类，实现了表现，数据，控制的分离。<br>开发者更多的是从技术的角度来对UI进行拆分，实现松耦合。<br>对于React而言，则完全是一个新的思路，开发者从功能的角度出发，将UI分成不同的组件，每个组件都独立封装。</p>
<p>在React中，你按照界面模块自然划分的方式来组织和编写你的代码，对于评论界面而言，<br>整个UI是一个通过小组件构成的大组件，每个组件只关心自己部分的逻辑，彼此独立。</p>
<p><img src="http://images.cnitblog.com/blog2015/622439/201505/072132381261891.png" alt="component"></p>
<p>React认为一个组件应该具有如下特征：<br>（1）可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。<br>如果一个组件内部创建了另一个组件，那么说父组件拥有（own）它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件；<br>（2）可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景；<br>（3）可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护；</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[position]]></title>
      <url>http://yoursite.com/2016/05/20/position/</url>
      <content type="html"><![CDATA[<p>元素在页面中的布局遵守一套文档流的方式，默认的定位属性值为static。它其实是未被设置定位的。<br>元素如果被定位了，那么它的top,left,bottom,right值就会生效，能设置定位的属性是relative,absolute和fixed。<br>需要注意的另一点是被定位的元素层次(z-index)会得到提高。<br><a id="more"></a></p>
<ol>
<li>relative<br> 自己通过定位跑开了还用着原来的位置，不会给周围的诸如文本流之类的元素<br> 设置了相对定位之后，通过修改top,left,bottom,right值，元素会在自身文档流所在位置上被移动，其他的元素则不会调整位置来弥补它偏离后剩下的空隙。<ul>
<li>不影响元素本身的特性</li>
<li>不使元素脱离文档流</li>
</ul>
</li>
<li>absolute<br> 设置了绝对定位之后，元素脱离文档流，其他的元素会调整位置来弥补它偏离后剩下的空隙。元素偏移是相对于是它最近的设置了定位属性（position值不为static）的元素。<ul>
<li>使元素完全脱离文档流</li>
<li>使内嵌元素支持宽高</li>
<li>块属性标签内容撑开宽度</li>
<li>如果有定位父级则相当于定位父级发生偏移，没有定位父级则相当于整个文档发生偏移</li>
</ul>
</li>
<li>fixed(固定定位)<br> 设置了固定定位之后，元素相对的偏移的参考是可视窗口，即使页面滚动，元素仍然会在固定位置</li>
<li>规定从父元素继承 position 属性的值。</li>
<li>position: sticky<br> 是一个新的css3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[定时器和线程]]></title>
      <url>http://yoursite.com/2016/05/15/timer/</url>
      <content type="html"><![CDATA[<p>读了《javascript 忍者秘籍》后对定时器的一些心得。</p>
<p>定时器提供了一种让一段代码在一定毫秒之后，在异步执行的能力。（html5 web worker 对定时器做了很多改变，IE不支持）</p>
<p>定时器有一个很重要的概念 <strong> javascript定时器的延迟时间是不确定的 </strong></p>
<p>在web worker可用之前，浏览器中的所有javascript代码都是在单线程中运行的。这种情况下，异步事件的处理程序，如用户界面事件和定时器，在线程中没有代码执行时才进行执行。也就是说，处理程序在执行时必须进行排队执行，并且一个处理程序不能中断另一个处理程序的执行。</p>
<blockquote>
<p>定时器对队列的工作方式是，当特定的时间过去后，将代码插入，注意添加到队列并不<br>意味着它会马上执行，而只能说它会尽快执行。对于定时器来说，指定的时间间隔表示何<br>时将定时器的代码添加到队列中，而不是何时执行代码。<br><a id="more"></a><br>举例来说，设定一个250ms后执行的定时器，不代表250ms后它会马上执行，它只会表示在250ms后被加入到队列中，如果这个时间点队列是空闲的，那么这段代码就会被执行。</p>
</blockquote>
<h2 id="浏览器内核处理方式"><a href="#浏览器内核处理方式" class="headerlink" title="浏览器内核处理方式"></a>浏览器内核处理方式</h2><p>浏览器内核实现允许多个线程异步执行,这些线程在内核制控下相互配合以保持同步.假如某一浏览器内核的实现至少有三个常驻线程:javascript引擎线程,界面渲染线程,浏览器事件触发线程,除些以外,也有一些执行完就终止的线程,如Http请求线程,这些异步线程都会产生不同的异步事件,下面通过一个图来阐明单线程的JavaScript引擎与另外那些线程是怎样互动通信的.虽然每个浏览器内核实现细节不同,但这其中的调用原理都是大同小异.</p>
<p><img src="http://laruence-wordpress.stor.sinaapp.com/uploads/jstimer.jpg" alt="browser"></p>
<p>由图可看出,浏览器中的JavaScript引擎是基于事件驱动的,事件驱动一般通过事件循环（event loop）和事件队列（event queue）来实现的.这里的事件可看作是浏览器派给它的各种任务,从代码角度看来任务实体就是各种回调函数,JavaScript引擎一直等待着任务队列中任务的到来.由于单线程关系,这些任务得进行排队,一个接着一个被引擎处理</p>
<pre><code>+ GUI渲染线程
    该线程负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行.该线程与JavaScript引擎线程是互斥的,这容易理解,因为JavaScript脚本是可操纵DOM元素,在修改这些元素属性同时渲染界面,那么渲染线程前后获得的元素数据就可能不一致了.
    在JavaScript引擎运行脚本期间,浏览器渲染线程都是处于挂起状态的,也就是说被”冻结”了.所以,在脚本中执行对界面进行更新操作,如添加结点,删除结点或改变结点的外观等更新并不会立即体现出来,这些操作将保存在一个队列中,待JavaScript引擎空闲时才有机会渲染出来.

+ GUI事件触发线程:
    JavaScript脚本的执行不影响html元素事件的触发,在t1时间段内,首先是用户点击了一个鼠标键,点击被浏览器事件触发线程捕捉后形成一个鼠标点击事件,由图可知,对于JavaScript引擎线程来说,这事件是由其它线程异步传到任务队列尾的,由于引擎正在处理t1时的任务,这个鼠标点击事件正在等待处理.

+ 定时触发线程:
    注意这里的浏览器模型定时计数器并不是由JavaScript引擎计数的,因为JavaScript引擎是单线程的,如果处于阻塞线程状态就计不了时,它必须依赖外部来计时并触发定时,所以队列中的定时事件也是异步事件.
</code></pre><h2 id="setTimeout-amp-set-Interval"><a href="#setTimeout-amp-set-Interval" class="headerlink" title="setTimeout &amp; set Interval"></a>setTimeout &amp; set Interval</h2><p>`<br>    setTimeout(function(){<br>        …<br>        setTimeout(repeat,10);<br>    },10);</p>
<pre><code>setInterval(function(){
    ...
},10);
</code></pre><p>`<br>这两段代码，功能看似相同，但实际上不是。setTimeout，要在前一个callback执行结束后并延迟10s，才再次执行。而setInterval则是每隔10s就尝试执行callback回调，而不关注上一个callback何时执行。</p>
<p>所以 <strong>setTimeout &amp; set Interval</strong>在触发周期上的定义是完全不同的。</p>
<p> setInterval创建的定时器确保了定时器规则地插入队列中，这个方式问题在于（1）某些间隔会被跳过了（2）多个定时器的代码执行间隔可能会比预期的要小 （3）如果一直被延迟，可能发生定时器无延迟执行，并且同一个interval处理程序的多个实例不能同时进行排队。</p>
<h2 id="定时器的用处"><a href="#定时器的用处" class="headerlink" title="定时器的用处"></a>定时器的用处</h2><ul>
<li>计算密集型的代码，将代码的各个部分分解成不会让浏览器挂掉的碎片</li>
<li>中央定时器控制</li>
<li>异步测试</li>
</ul>
<p>参考：《javascript 忍者秘籍》<br>        <a href="http://www.laruence.com/2009/09/23/1089.html" target="_blank" rel="external">http://www.laruence.com/2009/09/23/1089.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Animation小结]]></title>
      <url>http://yoursite.com/2016/05/10/animation/</url>
      <content type="html"><![CDATA[<p>实现平滑动画的两个因素：Frame Timing（新的一帧准备好的时机）&amp;&amp; Frame Budget（渲染新的一帧需要多长的时间）</p>
<h2 id="绘制频率"><a href="#绘制频率" class="headerlink" title="绘制频率"></a>绘制频率</h2><p>页面上每一帧变化都是系统绘制出来的(GPU或者CPU)，它的最高绘制频率受限于显示器的刷新频率(而非显卡)，所以大多数情况下最高的绘制频率只能是每秒60帧(frame per second，以下用fps简称)，对应于显示器的60Hz。60fps是一个最理想的状态，60fps是动力也是压力，因为它意味着我们只有16.7毫秒(1000 / 60)来绘制每一帧。在日常对页面性能的测试中，60fps也是一个重要的指标，the closer the better。</p>
<a id="more"></a>
<h2 id="刷新频率"><a href="#刷新频率" class="headerlink" title="刷新频率"></a>刷新频率</h2><p>图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹（Hz）。刷新频率越高，屏幕上图像闪烁感就越小，稳定性也就越高，换言之对视力的保护也越好。一般人的眼睛、不容易察觉75Hz以上刷新频率带来的闪烁感，因此最好能将您显示卡刷新频率调到75Hz以上。影响刷新率最主要的还是显示器的带宽。</p>
<blockquote>
<p>显示器带宽是显示器视频放大器通频带宽度的简称，指电子枪每秒钟在屏幕上扫过的最大总像素数，以MHz(兆赫兹)为单位。 带宽的值越大，显示器性能越好。</p>
</blockquote>
<h2 id="HZ-vs-fps"><a href="#HZ-vs-fps" class="headerlink" title="HZ vs fps"></a>HZ vs fps</h2><p>两者没有任何关系，fps代表GPU渲染画面的频率，Hz代表显示器刷新屏幕的频率。刷新率不随图像内容的变化而变化，游戏也好浏览器也好，我们谈到掉帧，是指GPU渲染画面频率降低。比如跌落到30fps甚至20fps，但因为视觉暂留原理，我们看到的画面仍然是运动和连贯的。</p>
<hr>
<h2 id="实现动画的几种方式"><a href="#实现动画的几种方式" class="headerlink" title="实现动画的几种方式"></a>实现动画的几种方式</h2><p>1、CSS Animation</p>
<ul>
<li><p>Transitions<br>css的transition允许css的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值。</p>
</li>
<li><p>Keyframes animation</p>
<blockquote>
<p>Keyframes animation通过定义多个关键帧以及定义每个关键帧中的元素的属性值来实现更为复杂的动画效。</p>
</blockquote>
</li>
<li><p>Pros</p>
<p> 简单、高效<br> 声明式的<br> 不依赖与主线程，采用硬件加速（GPU）<br> 简单的控制keyframe animation 播放和暂停。</p>
</li>
<li><p>Cons：<br> 不能动态的修改或定义动画内容<br> 不同的动画无法实现同步<br> 多个动画彼此无法堆叠</p>
<blockquote>
<p>CSS3 transition强制硬件加速会加大GPU消耗，高负荷情形下将导致运行不流畅。这种情况在移动设备上尤为明显。transition的兼容性问题是个诟病，IE10+及现代浏览器，使用起来会造成很多不便。</p>
</blockquote>
</li>
</ul>
<p>2、SVG</p>
<p>Pros：</p>
<ul>
<li>矢量图形，不受像素影响——SVG的这个特性使得它在不同的平台或者媒体下表现良好，无论屏幕分辨率如何。</li>
<li>SVG对动画的支持较好，其DOM结构可以被其特定语法或者Javascript控制，从而轻松的实现动画</li>
<li>Javascript可以完全控制SVG Dom 元素</li>
<li>SVG的结构是XML，其可访问性（盲文、声音朗读等）、可操作性、可编程性、可被CSS样式化完胜Canvas。另外，其支持 ARIA 属性，使其如虎添翼。</li>
</ul>
<p>Cons：</p>
<ul>
<li>DOM比正常的图形慢，而且如果其结点多而杂，就更慢。</li>
<li>SVG 画点报表什么的，还行；在网页游戏前，就束手无策了；当然可以结合 Canvas + SVG实现。</li>
<li>不能动态的修改动画内容，不能与HTML内容集成</li>
<li>浏览器兼容性问题，IE8-以及Android 2.3默认浏览器是不支持SVG</li>
</ul>
<p>3、Javascript</p>
<ul>
<li><p>js setInterval<br>Pros：易用，低效，兼容好；<br>Cons： setInterval多个间隔可能会被跳过，不同浏览器的精度量级不同，无法解决频繁触发 Layout 导致的抽动。</p>
</li>
<li><p>requestAnimationFrame<br>RequestAnimationFrame是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘。<br>Pros：</p>
<ul>
<li>在每次浏览器更新页面时，能获取通知并执行应用。 简单理解为，RAF能在每个16.7ms间执行一次函数，不多不少。</li>
<li>最小化的消耗资源，RAF在页面被切换或浏览器最小化时，会暂停执行，等页面再次关注时，继续执行动画。</li>
<li>相比 CSS 动画有更好的掌控，能合理降低CPU的使用。</li>
</ul>
<p>Cons：</p>
<ul>
<li>无法控制执行时间，执行时间由系统根据屏幕刷新时间决定。</li>
<li>浏览器兼容性问题，IE10+及现代浏览器，低版本浏览器建议降级处理，使用setInterval或setTimeout</li>
</ul>
</li>
<li><p>Canvas<br>Pros：</p>
<ul>
<li>画2D图形时，页面渲染性能比较高</li>
<li>页面渲染性能受图形复杂度影响小，渲染性能只受图形的分辨率的影响</li>
<li>画出来的图形可以直接保存为 .png 或者 .jpg的图形</li>
<li>最适合于画光栅图像（如游戏和不规则几何图形等），编辑图片还有其他基于像素的图形操作。</li>
</ul>
</li>
</ul>
<p> Cons：</p>
<ul>
<li>整个就是一张图，无论你往上画什么东西——没有DOM 结点可供操作</li>
<li>没有实现动画的API，你必须依靠定时器和其他事件来更新Canvas</li>
<li>对文本的渲染支持是比较差</li>
<li>对要求有高可访问性（盲文、声音朗读等）页面，比较困难</li>
<li>对交互要求高的（比如TIBCO的很多产品）的界面，不建议使用Canvas</li>
</ul>
<ul>
<li>WebGL</li>
</ul>
<blockquote>
<p>WebGL是一种3D绘图标准，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，通过增加OpenGL ES<br>2.0的一个JavaScript绑定，WebGL可以为HTML5 Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。显然，WebGL技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂3D结构的网站页面，甚至可以用来设计3D网&gt;页游戏等等。</p>
</blockquote>
<p>5、Web Animations 1.0 ——A new general purpose animation model</p>
<h2 id="现行兼容方案"><a href="#现行兼容方案" class="headerlink" title="现行兼容方案"></a>现行兼容方案</h2><pre><code>1、页面增强动画建议使用CSS动画
2、复杂动画交互建议使用RAF及setInterval 或setTimeout优雅降级处理
 推荐动画库Velocity.js、GreenSock
</code></pre><p>摘自：<a href="https://www.w3.org/TR/web-animations/" target="_blank" rel="external">https://www.w3.org/TR/web-animations/</a><br><a href="https://segmentfault.com/a/1190000002515384" target="_blank" rel="external">https://segmentfault.com/a/1190000002515384</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Progressive Enhancement]]></title>
      <url>http://yoursite.com/2016/05/09/strength/</url>
      <content type="html"><![CDATA[<h1 id="所谓农村包围城市——渐进增强"><a href="#所谓农村包围城市——渐进增强" class="headerlink" title="所谓农村包围城市——渐进增强"></a>所谓农村包围城市——渐进增强</h1><blockquote>
<p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
</blockquote>
<p>CSS的“渐进增强”有别于CSS hack，hack可以说是提供选择，你死我亡，竞争效应;而“渐进增强”属于更进一步，锦上添花，辅助效应。前者应尽量避免使用，而后者适当使用则有裨益。</p>
<p>渐进增强比较注重内容，即从内容出发，内容为样式和交互构建起坚实的基础。<br><a id="more"></a></p>
<p><img src="http://udn.yyuap.com/data/attachment/forum/201603/23/141022hs6166dgq64qfr1z.jpg" alt="此处输入图片的描述"></p>
<p>拿巧克力豆来类比，从内容(花生仁)讲起，它由丰富 (rich) 的语义化 (X)HTML 代码构成。包裹着内容的是一层浓郁 (rich) 的 CSS 奶油。最后，JavaScript 就是那层可以提升其美妙口感的坚硬糖衣。<br>有些人可能只喜欢吃花生仁，只注重内容（就像搜索引擎）。有些人喜欢巧克力包裹的花生仁，就像仅支持css的浏览器。而外观鲜艳的糖衣也是很多人的最爱，就像拥有丰富交互能力的浏览器。</p>
<hr>
<p>应用举例</p>
<ul>
<li>“渐进增强”之CSS3 text-shadow文字阴影属性</li>
<li>“渐进增强”之CSS3 border-radius圆角属性</li>
<li>“渐进增强”之CSS3 box-shadow盒阴影属性</li>
<li>“渐进增强”之CSS3 gradient渐变背景</li>
<li>CSS选择器、伪类与“渐进增强”</li>
</ul>
<p>参考：<a href="http://udn.yyuap.com/forum.php?mod=viewthread&amp;tid=101493" target="_blank" rel="external">http://udn.yyuap.com/forum.php?mod=viewthread&amp;tid=101493</a><br><a href="http://udn.yyuap.com/forum.php?mod=viewthread&amp;tid=101495" target="_blank" rel="external">http://udn.yyuap.com/forum.php?mod=viewthread&amp;tid=101495</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于 BFC]]></title>
      <url>http://yoursite.com/2016/05/08/BFC/</url>
      <content type="html"><![CDATA[<h1 id="关于-BFC"><a href="#关于-BFC" class="headerlink" title="关于 BFC"></a>关于 BFC</h1><p>BFC(Block formattingcontext)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干.(简单点说，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用)</p>
<p>W3C的定义`</p>
<blockquote>
<p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p>
</blockquote>
<a id="more"></a>
<p>BFC是一个独立的布局环境，我们可以理解为一个箱子（实际上是看不见摸不着的），箱子里面物品的摆放是不受外界的影响的。转换为BFC的理解则是：BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响。）并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</p>
<p> <strong>BFC布局规则</strong></p>
<ol>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>
<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ol>
<p><strong>产生BFC的元素</strong></p>
<ol>
<li>根元素</li>
<li>float属性不为none</li>
<li>overflow不为visible</li>
<li>display为inline-block, table-cell, table-caption, flex, inline-flexposition为absolute或fixed</li>
<li>position为absolute或fixed</li>
</ol>
<hr>
<p><strong>BFC作用</strong></p>
<p> <strong>1. 自适应两栏布局</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    .aside &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 150px;</span><br><span class="line">        float: left;</span><br><span class="line">        background: #f66;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    .main &#123;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background: #fcc;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class="aside"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class="main"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://p1.qhimg.com/d/inn/4055c62a/4dca44a927d4c1ffc30e3ae5f53a0b79.png" alt="此处输入图片的描述"><br>根据BFC布局规则第3条：</p>
<blockquote>
<p>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</p>
</blockquote>
<p>　　因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。<br>　根据BFC布局规则第四条：</p>
<blockquote>
<p> BFC的区域不会与float box重叠。</p>
</blockquote>
<p>　　我们可以通过通过触发main生成BFC， 来实现自适应两栏布局。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　当触发main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：<br><img src="http://p6.qhimg.com/t01077886a9706cb26b.png" alt="此处输入图片的描述"></p>
<hr>
<p> <strong>2. 防止垂直 margin 重叠</strong></p>
<h2 id="more"><a href="#more" class="headerlink" title="more"></a><a href="http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html" target="_blank" rel="external">more</a></h2><p><strong>BFC包含浮动</strong></p>
<p>  浮动元素是会脱离文档流的(绝对定位元素会脱离文档流)。如果一个没有高度或者<strong>height</strong>是<strong>auto</strong>的容器的子元素是浮动元素，则该容器的高度是不会被撑开的。我们通常会利用伪元素(<strong>:after</strong>或者<strong>:before</strong>)来解决这个问题。BFC能包含浮动，也能解决容器高度不会被撑开的问题。<br>  <img src="http://segmentfault.com/img/bVm2qT" alt="此处输入图片的描述"><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="container"&gt;</span><br><span class="line">    &lt;div&gt;Sibling&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;Sibling&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.container &#123;</span><br><span class="line">  background-color: green;</span><br><span class="line">&#125;</span><br><span class="line">.container div &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  background-color: lightgreen;</span><br><span class="line">  margin: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  在上面这个例子中，容器没有任何高度，并且它包不住浮动子元素，容器的高度并不会被撑开。为解决这个问题，可以在容器中创建一个BFC：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; <span class="comment">/* creates block formatting context */</span></span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  现在容器可以包住浮动子元素，并且其高度会扩展至包住其子元素，在这个新的BFC中浮动元素又回归到页面的常规流之中了。</p>
<hr>
<p><strong>使用BFC避免文字环绕</strong><br> <img src="http://segmentfault.com/img/bVm2qY" alt="此处输入图片的描述"><br>如上图所示，对于浮动元素，可能会造成文字环绕的情况(Figure1)，但这并不是我们想要的布局(Figure2才是想要的)。要解决这个问题，我们可以用外边距，但也可以用BFC。</p>
<hr>
<p><strong>在多列布局中使用BFC</strong><br>如果我们创建一个占满整个容器宽度的多列布局，在某些浏览器中最后一列有时候会掉到下一行。这可能是因为浏览器四舍五入了列宽从而所有列的总宽度会超出容器。但如果我们在多列布局中的最后一列里创建一个新的BFC，它将总是占据其他列先占位完毕后剩下的空间。</p>
<hr>
<p>参考文章：<br><a href="http://www.ido321.com/1642.html" target="_blank" rel="external">http://www.ido321.com/1642.html</a><br><a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="external">http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html</a><br><a href="http://www.html-js.com/article/1866" target="_blank" rel="external">http://www.html-js.com/article/1866</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浏览器缓存知识小结及应用（摘自开发者头条）]]></title>
      <url>http://yoursite.com/2016/05/07/cache/</url>
      <content type="html"><![CDATA[<p>浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数web开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发web应用的基础</p>
<a id="more"></a>
<ul>
<li><p>浏览器缓存基本认识<br>它分为强缓存和协商缓存： </p>
<ul>
<li>浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；</li>
<li>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</li>
<li><p>强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p>
</li>
<li><p>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p>
</li>
</ul>
</li>
<li><p>强缓存的原理<br>当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，比如京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的：</p>
<p> <img src="https://app.yinxiang.com/shard/s48/res/e37b1d50-657d-4de8-955e-a2da83632a94/267b4bb1b09acf9dce8b9d3c2d51c385" alt="此处输入图片的描述"></p>
<p> 强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</p>
<p> Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</p>
<ul>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header，如：<br><img src="https://app.yinxiang.com/shard/s48/res/5fb0f670-80ab-4a7c-9968-b8b83d7fad2b/a3900fb8564f0c815a88eaeb24be73f4" alt="此处输入图片的描述"></li>
<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。</li>
<li><p>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</p>
<p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p>
</li>
<li><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header，如：</p>
<p>  <img src="https://app.yinxiang.com/shard/s48/res/96a57d60-a17a-4f83-8fe8-ff57252788ca/1b7b7e3bcad38d6d026fc7571aca7ae3" alt="此处输入图片的描述"></p>
</li>
<li><p>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</p>
</li>
<li><p>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p>
</li>
<li><p>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。<br>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。<br>这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires：<br><img src="https://app.yinxiang.com/shard/s48/res/0080dc6f-727b-4a62-b97e-de8f17790bdc/b3a59cc4bdbe47b39f2a264f4066ee0e" alt="此处输入图片的描述"></p>
</li>
</ul>
</li>
<li><p>强缓存的管理<br>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存：</p>
<ul>
<li>通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</li>
<li><p>通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。<br>比如在javaweb里面，我们可以使用类似下面的代码设置强缓存：</p>
<p>  <code>java.util.Date date = new java.util.Date(); response.setDateHeader(&quot;Expires&quot;,date.getTime()+20000);</code> <code>//Expires:过时期限值  response.setHeader(&quot;Cache-Control&quot;, &quot;public&quot;); //Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息； response.setHeader(&quot;Pragma&quot;, &quot;Pragma&quot;); //Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存</code><br>还可以通过类似下面的java代码设置不启用强缓存：<br>  response.setHeader( “Pragma”, “no-cache” );<br>  response.setDateHeader(“Expires”, 0);<br>  response.addHeader( “Cache-Control”,”no-cache”);//浏览器和缓存服务器都不应该缓存页面信息<br>tomcat还提供了一个ExpiresFilter专门用来配置强缓存，具体使用的方式可参考tomcat的官方文档：<a href="http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#Expires_Filter" target="_blank" rel="external">http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#Expires_Filter</a></p>
<p>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css和js等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种：</p>
<p>1）直接ctrl+f5，这个办法能解决页面直接引用的资源更新的问题；</p>
<p>2）使用浏览器的隐私模式开发；</p>
<p>3）如果用的是chrome，可以f12在network那里把缓存给禁掉（这是个非常有效的方法）：</p>
<p><img src="https://app.yinxiang.com/shard/s48/res/e76f9b23-918f-432a-8473-62002c23e5b7/71cb7fa0a7d078a4db32a259f32514c8" alt="此处输入图片的描述"></p>
<p>4）在开发阶段，给资源加上一个动态的参数，如css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（v=${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题；</p>
<p>5）如果资源引用的页面，被嵌入到了一个iframe里面，可以在iframe的区域右键单击重新加载该页面<br>6）如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数；</p>
<p>7）还有一种情况就是动态设置iframe的src时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的src后面添加随机数也能解决问题；</p>
<p>8）如果你用的是grunt和gulp这种前端工具开发，通过它们的插件比如grunt-contrib-connect来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的respone header中，cache-control始终被设置为不缓存：</p>
<p><img src="https://app.yinxiang.com/shard/s48/res/6296223d-3aeb-44ba-b042-cb47509edbfb/2091309ef6c14d4aac23bbacf3756206" alt="此处输入图片的描述"></p>
</li>
</ul>
</li>
<li><p>强缓存的应用</p>
<p> 强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了2026年：</p>
<p> 然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果。</p>
<p> 这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：</p>
<p> <a href="http://www.zhihu.com/question/20790576" target="_blank" rel="external">http://www.zhihu.com/question/20790576</a></p>
<p> 文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，<br> <a href="http://fis.baidu.com/fis3/api/index.html" target="_blank" rel="external">http://fis.baidu.com/fis3/api/index.html</a><br> <a href="http://ecomfe.github.io/edp/doc/initialization/install/" target="_blank" rel="external">http://ecomfe.github.io/edp/doc/initialization/install/</a></p>
<p> 强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的html也可以看作是动态资源，如果这种html也被缓存，当这些html更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯html页面，每个访问地址可能都是直接访问html页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源。</p>
</li>
<li><p>协商缓存的原理<br>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的：</p>
<p> <img src="https://app.yinxiang.com/shard/s48/res/b6513373-5bdb-4c28-b9cd-1f47f28f9a60/90d3cb3dbddc1a861330242e62e914c3" alt="此处输入图片的描述"></p>
<p> 查看单个请求的Response Header，也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源：</p>
<p> <img src="https://app.yinxiang.com/shard/s48/res/1a949930-dc98-4369-a4d4-ddb90e8f862f/bf2df85505d5973e82931ec551fd979c" alt="此处输入图片的描述"></p>
<p> 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</p>
<p> 【Last-Modified，If-Modified-Since】的控制缓存的原理是：</p>
</li>
</ul>
<ul>
<li><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间：</p>
<p>   <img src="https://app.yinxiang.com/shard/s48/res/bc34251c-dcf5-4dfd-8c51-d4451e117519/dcc2a5a116497371919f129e18bb5456" alt="此处输入图片的描述"></p>
</li>
<li><p>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值：</p>
<pre><code>![此处输入图片的描述][10]
</code></pre></li>
<li><p>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header：<br><img src="https://app.yinxiang.com/shard/s48/res/d4d917ae-b44b-40e2-a717-f2a72c8486e2/becfc34765181dc722ac932190195443" alt="此处输入图片的描述"></p>
</li>
<li><p>浏览器收到304的响应后，就会从缓存中加载资源。</p>
</li>
<li><p>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</p>
<p>  【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：</p>
<ul>
<li><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：<br>  <img src="https://app.yinxiang.com/shard/s48/res/4fcb6bb2-ec3d-48f3-9f00-d1169a2b563e/db50348fc78f4f9fac8effcc4ea9cfa6" alt="此处输入图片的描述"></p>
</li>
<li><p>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值：<br>  <img src="https://app.yinxiang.com/shard/s48/res/fb4e5d97-dec9-4ffa-8120-d7fb2ca21282/c47ee065d0d9ecc91a5dd04a4d3f5453" alt="此处输入图片的描述"></p>
</li>
<li><p>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化：</p>
<p>  <img src="https://app.yinxiang.com/shard/s48/res/5b572cba-d447-44e1-9c44-4c8666b21713/006805f356d54197d824dc074b078986" alt="此处输入图片的描述"></p>
</li>
<li><p>浏览器收到304的响应后，就会从缓存中加载资源。</p>
</li>
</ul>
</li>
<li><p>协商缓存的管理<br>  协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache:</p>
<p>  <img src="https://app.yinxiang.com/shard/s48/res/ef0f8221-16ce-47b4-89cd-050c3aaa7961/c9c96dd7bf7185d24e667b00cc2fd52c" alt="此处输入图片的描述"></p>
<p>  如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p>
</li>
</ul>
<p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：<br>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；<br>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；<br>京东页面的资源请求，返回的repsones header就只有Last-Modified，没有ETag：<br>    <img src="https://app.yinxiang.com/shard/s48/res/70d4ca63-5c8c-418e-a676-73fe8929e028/f26bef7a05b521487fc8a38f6ebc0d72" alt="此处输入图片的描述"><br>协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义。</p>
<ul>
<li><p>浏览器行为对缓存的影响<br>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p>
<ul>
<li>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li>当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[float]]></title>
      <url>http://yoursite.com/2016/05/01/float/</url>
      <content type="html"><![CDATA[<p>元素设置了浮动，会脱离文档流，按照指定的一个方向移动直到碰到父级的边界或另一个浮动元素</p>
<p>浮动元素特点：</p>
<ul>
<li>块在一排显示</li>
<li>内联支持宽高</li>
<li>默认内容撑开宽度</li>
<li>脱离文档流（飘起来）</li>
<li>提升层级半级</li>
</ul>
<p>画一个元素的横切面，大概是这个样子<br><img src="http://o6qp6st9j.bkt.clouddn.com/image/blog/cssfloat.PNG" alt="1"><br>所以下一个元素挤进来只有元素本身进来，元素的内容就被挤出去了</p>
<p>清浮动：</p>
<ul>
<li>给父级也加浮动</li>
<li>空标签清浮动<code>&lt;br clear=”all” /&gt;</code></li>
<li>父元素设置 overflow:hidden（如果你还要兼顾IE6的话，加上*zoom:1;来触发hasLayout）</li>
<li>:after伪元素<br>`<br>.clearfix:after {<br>  clear: both;<br>  content: “.”;<br>  display: block;<br>  height: 0;<br>  visibility: hidden;<br>}<br>.clearfix {<br>  *zoom: 1;<br>}</li>
</ul>
<p>`</p>
<p>更多参照：<br> <a href="http://www.zhangxinxu.com/wordpress/?p=583，" target="_blank" rel="external">http://www.zhangxinxu.com/wordpress/?p=583，</a><br> <a href="https://www.zhihu.com/question/24529373/answer/29135021" target="_blank" rel="external">https://www.zhihu.com/question/24529373/answer/29135021</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浏览器兼容性]]></title>
      <url>http://yoursite.com/2016/04/20/browser/</url>
      <content type="html"><![CDATA[<blockquote>
<p>遇到的一些浏览器兼容问题</p>
</blockquote>
<ul>
<li><p>IE 与其他浏览器不一样的特性</p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IE支持currentStyle，FIrefox使用getComputStyle</span><br><span class="line"></span><br><span class="line">IE 使用innerText，Firefox使用textContent</span><br><span class="line"></span><br><span class="line">滤镜方面：IE:filter:alpha(opacity= num)；Firefox：-moz-opacity:num</span><br><span class="line"></span><br><span class="line">事件方面：IE：attachEvent：火狐是addEventListener</span><br><span class="line"></span><br><span class="line">鼠标位置：IE是event.clientX；火狐是event.pageX</span><br><span class="line"></span><br><span class="line">IE使用event.srcElement；Firefox使用event.target</span><br><span class="line"></span><br><span class="line">IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置margin:0;padding:0以及list-style:none</span><br><span class="line"></span><br><span class="line">CSS圆角：ie7以下不支持圆角</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>JS</strong></p>
<ul>
<li><p>NodeList对象转换为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">convertToArray</span>(<span class="params">nodes</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    array = <span class="built_in">Array</span>.prototype.splice.call(nodes,<span class="number">0</span>);<span class="comment">//IE8及更早将NodeList对象实现为一个com对象，所以会报错</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = nodes.length;i&lt;len;i++)&#123;</span><br><span class="line">        array.push(nodes[i]);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nodeType属性，用于表示节点的类型<br>  例如：Node.ELEMENT_NODE（1）<br>  确定节点的类型：<br>  someNode.NodeType == Node.ELEMENT_NODE //IE没有公开Node类型的构造函数，在IE中错误<br>  someNode.NodeType == 1 //兼容写法</p>
</li>
<li><p>cloneNode()<br>  cloneNode方法不会复制添加到DOM节点中的JavaScript属性，例如事件处理程序等。这个方法只复制特性、（参数为true会复制子节点），但IE会复制事件处理程序<br>  所以，复制之前最好先移除事件处理程序</p>
</li>
<li>IE下,event对象有x,y属性,但是没有pageX,pageY属性;<br>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性</li>
<li>链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:<br>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</li>
<li>document.doctype<ul>
<li>ie8及之前，会将文档类型声明解释为一个注释并当做Comment节点，document.doctype为null</li>
<li>IE9 FF：将文档类型声明作为文档第一个子节点，document.doctype为DocumentType对象</li>
<li>Safari、Chrome Opera：将其解析但不作为文档子节点</li>
</ul>
</li>
<li>getElementById<br>  在IE7中，若有表单元素的name特性值与给定id相等，则会返回表单元素</li>
<li>setAttribute()<br>  IE7及以前，通过这个方法设置的class和style特性，设置事件处理程序没有任何效果</li>
<li>document.createElement()</li>
<li>元素的子节点解析不一致<br>  childNodes 标准下包含了文本和元素类型的节点，非标准下，只包含元素类型的节点</li>
<li>matchesSelector()</li>
<li>元素遍历，对于元素间的空格，IE9及之前不会返回文本节点，而其他都会返回文本节点</li>
<li>innerHTML属性返回的值</li>
<li>contentDocument</li>
<li><p>页面坐标的位置</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">    EventUtil.addHandler(div,<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        event = EventUtil.getEvent(event);</span><br><span class="line">        <span class="keyword">var</span> pageX = event.pageX,</span><br><span class="line">            pageY = event.pageY;</span><br><span class="line">        <span class="keyword">if</span>(pageX == undefinded)&#123;</span><br><span class="line">            pageX = event.clientX + (<span class="built_in">document</span>.body.scrolLeft || <span class="built_in">document</span>.documentElement.scrolLeft;);</span><br><span class="line"><span class="comment">//IE7之前的版本：document.body</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pageY == undefinded)&#123;</span><br><span class="line">            pageY = event.clientY + (<span class="built_in">document</span>.body.scrolTop || <span class="built_in">document</span>.documentElement.scrolTop;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件</p>
<ul>
<li>标准事件监听elem.addEventListener(type, handler, capture)/elem.removeEventListener(type, handler, capture)：handler接收保存事件信息的event对象作为参数，event.target为触发事件的对象，handler调用上下文this为绑定监听器的对象，event.preventDefault()取消事件默认行为，event.stopPropagation()/event.stopImmediatePropagation()取消事件传递</li>
<li>老版本IE事件监听elem.attachEvent(‘on’+type, handler)/elem.detachEvent(‘on’+type, handler)：handler不接收event作为参数，事件信息保存在window.event中，触发事件的对象为event.srcElement，handler执行上下文this为window使用闭包中调用handler.call(elem, event)可模仿标准模型，然后返回闭包，保证了监听器的移除。event.returnValue为false时取消事件默认行为，event.cancleBubble为true时取消事件传播<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    addHandler:<span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener())&#123;</span><br><span class="line">            element.addEventListener(type, handler,<span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(<span class="string">"on"</span>+type,handler);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">"on"</span>+type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getEvent:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event?event||<span class="built_in">window</span>.event;</span><br><span class="line">    &#125;,</span><br><span class="line">    getTarget:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.preventDefault()) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            event.returnValue = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    removeHandler:<span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.removeEventListener())&#123;</span><br><span class="line">            element.removeEventListener(type, handler,<span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.detachEvent)&#123;</span><br><span class="line">            element.detachEvent(<span class="string">"on"</span>+type,handler);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">"on"</span>+type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    stopPropagation:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.stopPropagation()) &#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>窗口滚动条偏移量</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取指定window中滚动条的偏移量，如未指定则获取当前window</span><br><span class="line"> * 滚动条偏移量</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;window&#125; w 需要获取滚动条偏移量的窗口</span><br><span class="line"> * @return &#123;Object&#125; obj.x为水平滚动条偏移量,obj.y为竖直滚动条偏移量</span><br><span class="line"> */</span><br><span class="line">function getScrollOffset(w) &#123;</span><br><span class="line">    w =  w || window;</span><br><span class="line">    // 如果是标准浏览器</span><br><span class="line">    if (w.pageXOffset != null) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x: w.pageXOffset,</span><br><span class="line">            y: w.pageYOffset</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 老版本IE，根据兼容性不同访问不同元素</span><br><span class="line">    var d = w.document;</span><br><span class="line">    if (d.compatMode === 'CSS1Compat') &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x: d.documentElement.scrollLeft,</span><br><span class="line">            y: d.documentElement.scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        x: d.body.scrollLeft,</span><br><span class="line">        y: d.body.scrollTop</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回指定窗口的视口尺寸</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 查询指定窗口的视口尺寸，如果不指定窗口，查询当前窗口尺寸</span><br><span class="line">**/</span><br><span class="line">function getViewportSize(w) &#123;</span><br><span class="line">    w = w || window;</span><br><span class="line"></span><br><span class="line">    // IE9及标准浏览器中可使用此标准方法</span><br><span class="line">    if ('innerHeight' in w) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            width: w.innerWidth,</span><br><span class="line">            height: w.innerHeight</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var d = w.document;</span><br><span class="line">    // IE 8及以下浏览器在标准模式下</span><br><span class="line">    if (document.compatMode === 'CSS1Compat') &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            width: d.documentElement.clientWidth,</span><br><span class="line">            height: d.documentElement.clientHeight</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // IE8及以下浏览器在怪癖模式下</span><br><span class="line">    return &#123;</span><br><span class="line">        width: d.body.clientWidth,</span><br><span class="line">        height: d.body.clientHeight</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>css</strong></p>
<ul>
<li>IE6的双倍边距BUG 块元素有浮动和横向的margin，横向margin会被放大2倍<br>  display: inline</li>
<li>IE6下图片下方有空隙产生<br>  改变html的排版,或者设置img 为display:block，<br>或者设置vertical-align 属性为vertical-align:top bottom middle text-bottom都可以解决</li>
<li><p>3像素文本偏移bug<br>  当文本与一个浮动元素相邻时，例如：将一个元素向左浮动，并且不希望相邻段落中的文本围绕浮动元素，你也许会在段落上应用一个左外边距，其宽度等于浮动元素的宽度<br>  解决：</p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p&#123;height:1%;//迫使元素拥有布局，拥有布局的元素被限制为矩形，并且出现在浮动元素旁边</span><br><span class="line">margin-left:0;</span><br><span class="line">&#125;</span><br><span class="line">.myFloat&#123;</span><br><span class="line">margin-right:-3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>IE6 重复字符bug<br>  在某些情况下，一些列浮动元素的最后一个元素中的最后几个字符会在浮动元素下重复出现（当一系列浮动元素的第一个和最后一个元素之间有多个注释时，前两个注释没有影响，但后续的每个注释会导致两个字符重复出现）<br>  解决：可以通过设置负右外边距。最安全的：去掉注释</p>
</li>
<li><p>“藏猫猫bug”<br>  一个浮动元素后面跟着一些非浮动元素，然后是一个清理元素，所有这些元素都包含在一个设置了背景颜色或图像的父元素里，如果清理元素碰到了浮动元素，那么中间的非浮动元素看起来消失了，隐藏到了父元素的背景颜色或图像后面，只有在刷新页面时才会重新出现<br>  解决：给父容器一个明确的“宽度”或“高度”，例如height:1%</p>
<pre><code>或者：父容器和浮动元素的定位类型positon都设置为“相对”rellative
</code></pre></li>
<li><p>相对容器中的绝对定位<br>  相对元素没有获得IE内部的haslayout属性，因此不能创建新的上下文，所有绝对元素相对于视口定位<br>  <code>.container{height:1%;}</code></p>
</li>
<li><p>Chrome支持小于12px 的文字</p>
<ol>
<li>-webkit-text-size-adjust:none;通过它即可实现字体大小不随终端设备或浏览器影响。是在最新版的谷歌里。已经不在支持这个属性，需要通过css3的transform来解决</li>
<li><code>span{-webkit-transform:scale(0.8);-o-transform:scale(1); display:inline-block;}</code><br><code>{webkit-transform:scale(0.8);  display:inline-block} //0.8位缩放倍数</code>，具体自己根据实际需求修改，只能缩放可以定义宽高的元素，而span是行内元素，<br><code>{-o-transform:scale(1);}</code>opera现在最新版也是webkit内核，新版本的opera，本来就是10px的字体了</li>
</ol>
</li>
<li>display:inline-block 间隙<br>  真正意义上的inline-block水平呈现的元素间，换行显示或空格分隔的情况下会有间距<br>  解决：移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing<br>  <a href="http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/" target="_blank" rel="external">more</a></li>
<li><p>overflow: scroll时不能平滑滚动<br>  <code>-webkit-overflow-scrolling: touch</code><br>  <a href="http://www.cnblogs.com/PeunZhang/p/3553020.html" target="_blank" rel="external">more</a></p>
</li>
<li><p>IE 9选择器数量限制问题</p>
</li>
<li>IE8 resize<br>  <a href="https://undefinedblog.com/recent-ie-quirks/" target="_blank" rel="external">参考</a></li>
</ul>
<hr>
<ul>
<li><p>css Hack<br>  为了获得统一的页面效果，需要针对不同的浏览器或不同版本编写特定的CSS样式，这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack~</p>
<ul>
<li>CSS属性前缀法： IE6能识别下划线”<em>“和星号” <em> “，IE7能识别星号” </em> “，但不能识别下划线”</em>“，IE6~IE10都认识”\9”，但firefox前述三个都不能认识。</li>
<li>选择器前缀法：例如 IE6能识别<em>html .class{}，IE7能识别</em>+html .class{}或者*:first-child+html .class{}。</li>
<li>IE条件注释法：针对所有IE(注：IE10+已经不再支持条件注释)： <code>&lt;!--[if IE]&gt;IE浏览器显示的内容 &lt;![endif]--&gt;</code>，针对IE6及以下版本： <code>&lt;!--[if lt IE 6]&gt;只在IE6-显示的内容 &lt;![endif]--&gt;</code>。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。<br><a href="http://blog.csdn.net/freshlover/article/details/12132801" target="_blank" rel="external">more</a></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[宿主机连接linux web服务器失败]]></title>
      <url>http://yoursite.com/2016/04/15/linux/</url>
      <content type="html"><![CDATA[<p>环境：centos xftp xshell<br>原因分析：linux的问题、VMware的问题、windows的问题<br><a id="more"></a></p>
<ul>
<li>linux的问题：<ul>
<li>iptables -F<br> iptables -P INPUT ACCEPT（设置默认允许规则）</li>
<li>设置linux防火墙<br>  在 /etc/sysconfig/iptables 添加<pre><code>-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT
</code></pre> 在linux中将web服务添加进入信任的服务中<pre><code>系统-&gt;管理-&gt;安全级别和防火墙-&gt;防火墙选项-&gt;将www（http）打钩
</code></pre></li>
</ul>
</li>
<li>VMware的问题：是否在端口转发上出问题<br>设置VMware，端口转发<br>要把80端口打开，还要在VMware的Edit-&gt;Virtual Network Editor-&gt;NAT（选择VMnet8）-&gt;Edit-&gt;Port Forwarding中添加转发<br><img src="http://o6qp6st9j.bkt.clouddn.com/1.PNG" alt="此处输入图片的描述"></li>
<li>windows问题<ul>
<li>windows主机上设置防火墙<br>window下进入控制面板-&gt;windows防火墙-&gt;高级-&gt;设置VMware Network Adapter VMnet8-&gt;Web 服务器（HTTP）-&gt;将虚拟机的ip加入：192.168.152.129</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WHOIS 特征提取及 URL Parse（持续更新）]]></title>
      <url>http://yoursite.com/2016/04/10/whois/</url>
      <content type="html"><![CDATA[<p>DataSet： <strong>PhishTank &amp;&amp; DMOZ</strong>   -数据集不平衡</p>
<pre><code>PhishTank爬取 23378条URL （2008-2016） 
DMOZ 定时更新
</code></pre><a id="more"></a>
<h2 id="WHOIS"><a href="#WHOIS" class="headerlink" title="WHOIS"></a>WHOIS</h2><ul>
<li><a href="https://github.com/secynic/ipwhois" target="_blank" rel="external">使用python 获取</a></li>
<li><a href="https://github.com/weppos/whois" target="_blank" rel="external">使用Ruby 获取</a></li>
</ul>
<h2 id="URL-Parse"><a href="#URL-Parse" class="headerlink" title="URL Parse"></a>URL Parse</h2><ul>
<li><a href="https://github.com/cherishsdan/js-url" target="_blank" rel="external">使用js 解析</a></li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
